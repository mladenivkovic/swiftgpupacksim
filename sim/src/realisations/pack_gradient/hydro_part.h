/**
  * WARNING: THIS FILE WAS GENERATED. MODIFICATIONS WILL NOT STICK.
  * File template is /home/mivkov/Durham/swiftgpupacksim/py/templates/hydro_part.h.jinja.template
  */


#ifndef SWIFT_HYDRO_PART_7950cb4e488e9b2bbe2cafc74745dc6bc0eeca11_H
#define SWIFT_HYDRO_PART_7950cb4e488e9b2bbe2cafc74745dc6bc0eeca11_H

 

#include "align.h"
#include "error.h"
#include "hydro_part_placeholder_structs.h"
#include "hydro_part_arrays_struct.h"
#include "rt_struct.h"
#include "timestep_limiter_struct.h"

#include <float.h>
#include <limits.h>
#include <stddef.h>


struct part {
  /*! offset/index of particle in cell particle data array */
  size_t _cell_offset;

  /*! pointer to particle data array struct of the cell this particle is located in */
  struct hydro_part_arrays* _cell_part_arrays;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct x_h_v_m {
  /*! the particle position */
  double _x[3];

  /*! Particle smoothing length */
  float _h;

  /*! Particle predicted velocity */
  float _v[3];

  /*! Particle mass */
  float _mass;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct gradient_pack {
  /*! Particle internal energy */
  float _u;

  /*! Particle density */
  float _rho;

  /*! Particle soundspeed */
  float _soundspeed;

  /*! Maximal alpha (viscosity) over neighbours */
  float _alpha_visc_max_ngb;

  /*! Artificial viscosity parameter */
  float _alpha_av;

  /*! Signal velocity */
  float _v_sig;

  /*! del^2 u, a smoothed quantity */
  float _laplace_u;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct force_pack {
  /*! 'Grad h' term -- only partial in P-U */
  float _f_gradh;

  /*! Particle pressure */
  float _pressure;

  /*! Balsara switch */
  float _balsara;

  /*! Thermal diffusion coefficient */
  float _alpha_diff;

  /*! Time-step length */
  timebin_t _time_bin;

  /*! Time-step limiter information */
  struct timestep_limiter_data _limiter_data;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct density_unpack {
  /*! Derivative of density with respect to h */
  float _rho_dh;

  /*! Neighbour number count */
  float _wcount;

  /*! Derivative of the neighbour number with respect to h */
  float _wcount_dh;

  /*! Particle velocity curl */
  float _rot_v[3];

  /*! Particle velocity divergence */
  float _div_v;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct force_unpack {
  /*! Particle acceleration */
  float _a_hydro[3];

  /*! Time derivative of the internal energy */
  float _u_dt;

  /*! Time derivative of smoothing length */
  float _h_dt;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct others {
  /*! Time differential of velocity divergence */
  float _div_v_dt;

  /*! Particle velocity divergence from previous step */
  float _div_v_previous_step;

  /*! Particle unique ID */
  long long _id;

  /*! Pointer to corresponding gravity part */
  struct gpart* _gpart;

  /*! Additional data used for adaptive softening */
  struct adaptive_softening_part_data _adaptive_softening_data;

  /*! Additional data used by the MHD scheme */
  struct mhd_part_data _mhd_data;

  /*! Chemistry information */
  struct chemistry_part_data _chemistry_data;

  /*! Cooling information */
  struct cooling_part_data _cooling_data;

  /*! Additional data used by the feedback */
  struct feedback_part_data _feedback_data;

  /*! Black holes information (eg swallowing ID) */
  struct black_holes_part_data _black_holes_data;

  /*! Sink information (eg swallowing ID) */
  struct sink_part_data _sink_data;

  /*! Additional data used by the pressure floor */
  struct pressure_floor_part_data _pressure_floor_data;

  /*! Additional Radiative Transfer Data */
  struct rt_part_data _rt_data;

  /*! RT sub-cycling time stepping data */
  struct rt_timestepping_data _rt_time_data;

  /*! Tree-depth at which size / 2 <= h * gamma < size */
  char _depth_h;

#ifdef SWIFT_DEBUG_CHECKS
  /*! Time of the last drift */
  integertime_t _ti_drift;
#endif

#ifdef SWIFT_DEBUG_CHECKS
  /*! Time of the last drift */
  integertime_t _ti_kick;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Integer number of neighbours in the density loop */
  int _N_density;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact integer number of neighbours in the density loop */
  int _N_density_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Integer number of neighbours in the gradient loop */
  int _N_gradient;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact integer number of neighbours in the gradient loop */
  int _N_gradient_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Integer number of neighbours in the force loop */
  int _N_force;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact integer number of neighbours in the force loop */
  int _N_force_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact value of the density field obtained via brute-force loop */
  float _rho_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Weighted number of neighbours in the density loop */
  float _n_density;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact value of the weighted number of neighbours in the density loop */
  float _n_density_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Weighted number of neighbours in the gradient loop */
  float _n_gradient;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact value of the weighted number of neighbours in the gradient loop */
  float _n_gradient_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Weighted number of neighbours in the force loop */
  float _n_force;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact value of the weighted number of neighbours in the force loop */
  float _n_force_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Has this particle interacted with any unhibited neighbour? */
  char _inhibited_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Has this particle been woken up by the limiter? */
  char _limited_part;
#endif

  /*! Geometrical quantities used for Finite Volume Particle Method RT */
  struct fvpm_geometry_struct _geometry;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;


/**
 * @brief get cell_offset, offset/index of particle in cell particle data array.
 */
static __attribute__((always_inline)) INLINE size_t
  part_get_cell_offset(const struct part *restrict p) {
  return p->_cell_offset;
}

/**
 * @brief get a pointer to cell_offset, offset/index of particle in cell particle data array.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to cell_offset. If you need read-only access to cell_offset, use part_get_const_cell_offset_p() instead.
 */
static __attribute__((always_inline)) INLINE size_t*
  part_get_cell_offset_p(struct part *restrict p) {
  return &p->_cell_offset;
}

/**
 * @brief get read-only access to pointer to cell_offset,
 * offset/index of particle in cell particle data array.
 * If you need write access to cell_offset, use part_get_cell_offset_p() instead.
 */
static __attribute__((always_inline)) INLINE const size_t*
  part_get_const_cell_offset_p(const struct part *restrict p) {
  return &p->_cell_offset;
}

/**
 * @brief set the value of cell_offset, offset/index of particle in cell particle data array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_cell_offset(struct part *restrict p, const size_t cell_offset) {
  p->_cell_offset = cell_offset;
}




/**
 * @brief get cell_part_arrays, pointer to particle data array struct of the cell this particle is located in.
 */
static __attribute__((always_inline)) INLINE struct hydro_part_arrays*
  part_get_cell_part_arrays(const struct part *restrict p) {
  return p->_cell_part_arrays;
}

/**
 * @brief get a pointer to cell_part_arrays, pointer to particle data array struct of the cell this particle is located in.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to cell_part_arrays. If you need read-only access to cell_part_arrays, use part_get_const_cell_part_arrays_p() instead.
 */
static __attribute__((always_inline)) INLINE struct hydro_part_arrays**
  part_get_cell_part_arrays_p(struct part *restrict p) {
  return &p->_cell_part_arrays;
}/**
 * @brief set the value of cell_part_arrays, pointer to particle data array struct of the cell this particle is located in.
 */
static __attribute__((always_inline)) INLINE void
  part_set_cell_part_arrays(struct part *restrict p,  struct hydro_part_arrays* cell_part_arrays) {
  p->_cell_part_arrays = cell_part_arrays;
}






/**
 * @brief get x, the particle position,
 * for read and write access. For read-only access, use
 * part_get_const_x() instead.
 */
static __attribute__((always_inline)) INLINE double*
  part_get_x(struct part *restrict p) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return x_h_v_m_s->_x;
}

/**
 * @brief get x, the particle position, for read-only access.
 */
static __attribute__((always_inline)) INLINE const double*
  part_get_const_x(const struct part *restrict p) {
  const struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return x_h_v_m_s->_x;
}

/**
 * @brief get x, the particle position, by index.
 */
static __attribute__((always_inline)) INLINE double
  part_get_x_ind(const struct part *restrict p, const size_t ind) {
  const struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return x_h_v_m_s->_x[ind];
}

/**
 * @brief set all values of x, the particle position,
 * from an array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_x(struct part *restrict p, const double x[3]) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  x_h_v_m_s->_x[0] = x[0];
  x_h_v_m_s->_x[1] = x[1];
  x_h_v_m_s->_x[2] = x[2];
}

/**
 * @brief set the value of x, the particle position, by index.
 */
static __attribute__((always_inline)) INLINE void
  part_set_x_ind(struct part *restrict p, const size_t i, const double x) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  x_h_v_m_s->_x[i] = x;
}




/**
 * @brief get h, Particle smoothing length.
 */
static __attribute__((always_inline)) INLINE float
  part_get_h(const struct part *restrict p) {
  const struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return x_h_v_m_s->_h;
}

/**
 * @brief get a pointer to h, Particle smoothing length.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to h. If you need read-only access to h, use part_get_const_h_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_h_p(struct part *restrict p) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return &x_h_v_m_s->_h;
}

/**
 * @brief get read-only access to pointer to h,
 * Particle smoothing length.
 * If you need write access to h, use part_get_h_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_h_p(const struct part *restrict p) {
  const struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return &x_h_v_m_s->_h;
}

/**
 * @brief set the value of h, Particle smoothing length.
 */
static __attribute__((always_inline)) INLINE void
  part_set_h(struct part *restrict p, const float h) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  x_h_v_m_s->_h = h;
}




/**
 * @brief get v, Particle predicted velocity,
 * for read and write access. For read-only access, use
 * part_get_const_v() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_v(struct part *restrict p) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return x_h_v_m_s->_v;
}

/**
 * @brief get v, Particle predicted velocity, for read-only access.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_v(const struct part *restrict p) {
  const struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return x_h_v_m_s->_v;
}

/**
 * @brief get v, Particle predicted velocity, by index.
 */
static __attribute__((always_inline)) INLINE float
  part_get_v_ind(const struct part *restrict p, const size_t ind) {
  const struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return x_h_v_m_s->_v[ind];
}

/**
 * @brief set all values of v, Particle predicted velocity,
 * from an array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_v(struct part *restrict p, const float v[3]) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  x_h_v_m_s->_v[0] = v[0];
  x_h_v_m_s->_v[1] = v[1];
  x_h_v_m_s->_v[2] = v[2];
}

/**
 * @brief set the value of v, Particle predicted velocity, by index.
 */
static __attribute__((always_inline)) INLINE void
  part_set_v_ind(struct part *restrict p, const size_t i, const float v) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  x_h_v_m_s->_v[i] = v;
}




/**
 * @brief get mass, Particle mass.
 */
static __attribute__((always_inline)) INLINE float
  part_get_mass(const struct part *restrict p) {
  const struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return x_h_v_m_s->_mass;
}

/**
 * @brief get a pointer to mass, Particle mass.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to mass. If you need read-only access to mass, use part_get_const_mass_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_mass_p(struct part *restrict p) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return &x_h_v_m_s->_mass;
}

/**
 * @brief get read-only access to pointer to mass,
 * Particle mass.
 * If you need write access to mass, use part_get_mass_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_mass_p(const struct part *restrict p) {
  const struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  return &x_h_v_m_s->_mass;
}

/**
 * @brief set the value of mass, Particle mass.
 */
static __attribute__((always_inline)) INLINE void
  part_set_mass(struct part *restrict p, const float mass) {
  struct x_h_v_m* x_h_v_m_s = p->_cell_part_arrays->_x_h_v_m + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(x_h_v_m_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", x_h_v_m_s->_accessor_id, p->_accessor_id);
#endif
  x_h_v_m_s->_mass = mass;
}






/**
 * @brief get u, Particle internal energy.
 */
static __attribute__((always_inline)) INLINE float
  part_get_u(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return gradient_pack_s->_u;
}

/**
 * @brief get a pointer to u, Particle internal energy.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to u. If you need read-only access to u, use part_get_const_u_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_u_p(struct part *restrict p) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_u;
}

/**
 * @brief get read-only access to pointer to u,
 * Particle internal energy.
 * If you need write access to u, use part_get_u_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_u_p(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_u;
}

/**
 * @brief set the value of u, Particle internal energy.
 */
static __attribute__((always_inline)) INLINE void
  part_set_u(struct part *restrict p, const float u) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  gradient_pack_s->_u = u;
}




/**
 * @brief get rho, Particle density.
 */
static __attribute__((always_inline)) INLINE float
  part_get_rho(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return gradient_pack_s->_rho;
}

/**
 * @brief get a pointer to rho, Particle density.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rho. If you need read-only access to rho, use part_get_const_rho_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_rho_p(struct part *restrict p) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_rho;
}

/**
 * @brief get read-only access to pointer to rho,
 * Particle density.
 * If you need write access to rho, use part_get_rho_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_rho_p(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_rho;
}

/**
 * @brief set the value of rho, Particle density.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rho(struct part *restrict p, const float rho) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  gradient_pack_s->_rho = rho;
}




/**
 * @brief get soundspeed, Particle soundspeed.
 */
static __attribute__((always_inline)) INLINE float
  part_get_soundspeed(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return gradient_pack_s->_soundspeed;
}

/**
 * @brief get a pointer to soundspeed, Particle soundspeed.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to soundspeed. If you need read-only access to soundspeed, use part_get_const_soundspeed_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_soundspeed_p(struct part *restrict p) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_soundspeed;
}

/**
 * @brief get read-only access to pointer to soundspeed,
 * Particle soundspeed.
 * If you need write access to soundspeed, use part_get_soundspeed_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_soundspeed_p(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_soundspeed;
}

/**
 * @brief set the value of soundspeed, Particle soundspeed.
 */
static __attribute__((always_inline)) INLINE void
  part_set_soundspeed(struct part *restrict p, const float soundspeed) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  gradient_pack_s->_soundspeed = soundspeed;
}




/**
 * @brief get alpha_visc_max_ngb, Maximal alpha (viscosity) over neighbours.
 */
static __attribute__((always_inline)) INLINE float
  part_get_alpha_visc_max_ngb(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return gradient_pack_s->_alpha_visc_max_ngb;
}

/**
 * @brief get a pointer to alpha_visc_max_ngb, Maximal alpha (viscosity) over neighbours.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to alpha_visc_max_ngb. If you need read-only access to alpha_visc_max_ngb, use part_get_const_alpha_visc_max_ngb_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_alpha_visc_max_ngb_p(struct part *restrict p) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_alpha_visc_max_ngb;
}

/**
 * @brief get read-only access to pointer to alpha_visc_max_ngb,
 * Maximal alpha (viscosity) over neighbours.
 * If you need write access to alpha_visc_max_ngb, use part_get_alpha_visc_max_ngb_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_alpha_visc_max_ngb_p(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_alpha_visc_max_ngb;
}

/**
 * @brief set the value of alpha_visc_max_ngb, Maximal alpha (viscosity) over neighbours.
 */
static __attribute__((always_inline)) INLINE void
  part_set_alpha_visc_max_ngb(struct part *restrict p, const float alpha_visc_max_ngb) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  gradient_pack_s->_alpha_visc_max_ngb = alpha_visc_max_ngb;
}




/**
 * @brief get alpha_av, Artificial viscosity parameter.
 */
static __attribute__((always_inline)) INLINE float
  part_get_alpha_av(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return gradient_pack_s->_alpha_av;
}

/**
 * @brief get a pointer to alpha_av, Artificial viscosity parameter.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to alpha_av. If you need read-only access to alpha_av, use part_get_const_alpha_av_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_alpha_av_p(struct part *restrict p) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_alpha_av;
}

/**
 * @brief get read-only access to pointer to alpha_av,
 * Artificial viscosity parameter.
 * If you need write access to alpha_av, use part_get_alpha_av_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_alpha_av_p(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_alpha_av;
}

/**
 * @brief set the value of alpha_av, Artificial viscosity parameter.
 */
static __attribute__((always_inline)) INLINE void
  part_set_alpha_av(struct part *restrict p, const float alpha_av) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  gradient_pack_s->_alpha_av = alpha_av;
}




/**
 * @brief get v_sig, Signal velocity.
 */
static __attribute__((always_inline)) INLINE float
  part_get_v_sig(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return gradient_pack_s->_v_sig;
}

/**
 * @brief get a pointer to v_sig, Signal velocity.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to v_sig. If you need read-only access to v_sig, use part_get_const_v_sig_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_v_sig_p(struct part *restrict p) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_v_sig;
}

/**
 * @brief get read-only access to pointer to v_sig,
 * Signal velocity.
 * If you need write access to v_sig, use part_get_v_sig_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_v_sig_p(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_v_sig;
}

/**
 * @brief set the value of v_sig, Signal velocity.
 */
static __attribute__((always_inline)) INLINE void
  part_set_v_sig(struct part *restrict p, const float v_sig) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  gradient_pack_s->_v_sig = v_sig;
}




/**
 * @brief get laplace_u, del^2 u, a smoothed quantity.
 */
static __attribute__((always_inline)) INLINE float
  part_get_laplace_u(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return gradient_pack_s->_laplace_u;
}

/**
 * @brief get a pointer to laplace_u, del^2 u, a smoothed quantity.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to laplace_u. If you need read-only access to laplace_u, use part_get_const_laplace_u_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_laplace_u_p(struct part *restrict p) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_laplace_u;
}

/**
 * @brief get read-only access to pointer to laplace_u,
 * del^2 u, a smoothed quantity.
 * If you need write access to laplace_u, use part_get_laplace_u_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_laplace_u_p(const struct part *restrict p) {
  const struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &gradient_pack_s->_laplace_u;
}

/**
 * @brief set the value of laplace_u, del^2 u, a smoothed quantity.
 */
static __attribute__((always_inline)) INLINE void
  part_set_laplace_u(struct part *restrict p, const float laplace_u) {
  struct gradient_pack* gradient_pack_s = p->_cell_part_arrays->_gradient_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(gradient_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", gradient_pack_s->_accessor_id, p->_accessor_id);
#endif
  gradient_pack_s->_laplace_u = laplace_u;
}






/**
 * @brief get f_gradh, 'Grad h' term -- only partial in P-U.
 */
static __attribute__((always_inline)) INLINE float
  part_get_f_gradh(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return force_pack_s->_f_gradh;
}

/**
 * @brief get a pointer to f_gradh, 'Grad h' term -- only partial in P-U.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to f_gradh. If you need read-only access to f_gradh, use part_get_const_f_gradh_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_f_gradh_p(struct part *restrict p) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_f_gradh;
}

/**
 * @brief get read-only access to pointer to f_gradh,
 * 'Grad h' term -- only partial in P-U.
 * If you need write access to f_gradh, use part_get_f_gradh_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_f_gradh_p(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_f_gradh;
}

/**
 * @brief set the value of f_gradh, 'Grad h' term -- only partial in P-U.
 */
static __attribute__((always_inline)) INLINE void
  part_set_f_gradh(struct part *restrict p, const float f_gradh) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  force_pack_s->_f_gradh = f_gradh;
}




/**
 * @brief get pressure, Particle pressure.
 */
static __attribute__((always_inline)) INLINE float
  part_get_pressure(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return force_pack_s->_pressure;
}

/**
 * @brief get a pointer to pressure, Particle pressure.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to pressure. If you need read-only access to pressure, use part_get_const_pressure_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_pressure_p(struct part *restrict p) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_pressure;
}

/**
 * @brief get read-only access to pointer to pressure,
 * Particle pressure.
 * If you need write access to pressure, use part_get_pressure_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_pressure_p(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_pressure;
}

/**
 * @brief set the value of pressure, Particle pressure.
 */
static __attribute__((always_inline)) INLINE void
  part_set_pressure(struct part *restrict p, const float pressure) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  force_pack_s->_pressure = pressure;
}




/**
 * @brief get balsara, Balsara switch.
 */
static __attribute__((always_inline)) INLINE float
  part_get_balsara(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return force_pack_s->_balsara;
}

/**
 * @brief get a pointer to balsara, Balsara switch.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to balsara. If you need read-only access to balsara, use part_get_const_balsara_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_balsara_p(struct part *restrict p) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_balsara;
}

/**
 * @brief get read-only access to pointer to balsara,
 * Balsara switch.
 * If you need write access to balsara, use part_get_balsara_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_balsara_p(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_balsara;
}

/**
 * @brief set the value of balsara, Balsara switch.
 */
static __attribute__((always_inline)) INLINE void
  part_set_balsara(struct part *restrict p, const float balsara) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  force_pack_s->_balsara = balsara;
}




/**
 * @brief get alpha_diff, Thermal diffusion coefficient.
 */
static __attribute__((always_inline)) INLINE float
  part_get_alpha_diff(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return force_pack_s->_alpha_diff;
}

/**
 * @brief get a pointer to alpha_diff, Thermal diffusion coefficient.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to alpha_diff. If you need read-only access to alpha_diff, use part_get_const_alpha_diff_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_alpha_diff_p(struct part *restrict p) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_alpha_diff;
}

/**
 * @brief get read-only access to pointer to alpha_diff,
 * Thermal diffusion coefficient.
 * If you need write access to alpha_diff, use part_get_alpha_diff_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_alpha_diff_p(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_alpha_diff;
}

/**
 * @brief set the value of alpha_diff, Thermal diffusion coefficient.
 */
static __attribute__((always_inline)) INLINE void
  part_set_alpha_diff(struct part *restrict p, const float alpha_diff) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  force_pack_s->_alpha_diff = alpha_diff;
}




/**
 * @brief get time_bin, Time-step length.
 */
static __attribute__((always_inline)) INLINE timebin_t
  part_get_time_bin(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return force_pack_s->_time_bin;
}

/**
 * @brief get a pointer to time_bin, Time-step length.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to time_bin. If you need read-only access to time_bin, use part_get_const_time_bin_p() instead.
 */
static __attribute__((always_inline)) INLINE timebin_t*
  part_get_time_bin_p(struct part *restrict p) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_time_bin;
}

/**
 * @brief get read-only access to pointer to time_bin,
 * Time-step length.
 * If you need write access to time_bin, use part_get_time_bin_p() instead.
 */
static __attribute__((always_inline)) INLINE const timebin_t*
  part_get_const_time_bin_p(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_time_bin;
}

/**
 * @brief set the value of time_bin, Time-step length.
 */
static __attribute__((always_inline)) INLINE void
  part_set_time_bin(struct part *restrict p, const timebin_t time_bin) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  force_pack_s->_time_bin = time_bin;
}




/**
 * @brief get limiter_data, Time-step limiter information.
 */
static __attribute__((always_inline)) INLINE struct timestep_limiter_data
  part_get_limiter_data(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return force_pack_s->_limiter_data;
}

/**
 * @brief get a pointer to limiter_data, Time-step limiter information.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to limiter_data. If you need read-only access to limiter_data, use part_get_const_limiter_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct timestep_limiter_data*
  part_get_limiter_data_p(struct part *restrict p) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_limiter_data;
}

/**
 * @brief get read-only access to pointer to limiter_data,
 * Time-step limiter information.
 * If you need write access to limiter_data, use part_get_limiter_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct timestep_limiter_data*
  part_get_const_limiter_data_p(const struct part *restrict p) {
  const struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_pack_s->_limiter_data;
}

/**
 * @brief set the value of limiter_data, Time-step limiter information.
 */
static __attribute__((always_inline)) INLINE void
  part_set_limiter_data(struct part *restrict p, const struct timestep_limiter_data limiter_data) {
  struct force_pack* force_pack_s = p->_cell_part_arrays->_force_pack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_pack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_pack_s->_accessor_id, p->_accessor_id);
#endif
  force_pack_s->_limiter_data = limiter_data;
}






/**
 * @brief get rho_dh, Derivative of density with respect to h.
 */
static __attribute__((always_inline)) INLINE float
  part_get_rho_dh(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return density_unpack_s->_rho_dh;
}

/**
 * @brief get a pointer to rho_dh, Derivative of density with respect to h.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rho_dh. If you need read-only access to rho_dh, use part_get_const_rho_dh_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_rho_dh_p(struct part *restrict p) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &density_unpack_s->_rho_dh;
}

/**
 * @brief get read-only access to pointer to rho_dh,
 * Derivative of density with respect to h.
 * If you need write access to rho_dh, use part_get_rho_dh_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_rho_dh_p(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &density_unpack_s->_rho_dh;
}

/**
 * @brief set the value of rho_dh, Derivative of density with respect to h.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rho_dh(struct part *restrict p, const float rho_dh) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  density_unpack_s->_rho_dh = rho_dh;
}




/**
 * @brief get wcount, Neighbour number count.
 */
static __attribute__((always_inline)) INLINE float
  part_get_wcount(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return density_unpack_s->_wcount;
}

/**
 * @brief get a pointer to wcount, Neighbour number count.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to wcount. If you need read-only access to wcount, use part_get_const_wcount_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_wcount_p(struct part *restrict p) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &density_unpack_s->_wcount;
}

/**
 * @brief get read-only access to pointer to wcount,
 * Neighbour number count.
 * If you need write access to wcount, use part_get_wcount_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_wcount_p(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &density_unpack_s->_wcount;
}

/**
 * @brief set the value of wcount, Neighbour number count.
 */
static __attribute__((always_inline)) INLINE void
  part_set_wcount(struct part *restrict p, const float wcount) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  density_unpack_s->_wcount = wcount;
}




/**
 * @brief get wcount_dh, Derivative of the neighbour number with respect to h.
 */
static __attribute__((always_inline)) INLINE float
  part_get_wcount_dh(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return density_unpack_s->_wcount_dh;
}

/**
 * @brief get a pointer to wcount_dh, Derivative of the neighbour number with respect to h.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to wcount_dh. If you need read-only access to wcount_dh, use part_get_const_wcount_dh_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_wcount_dh_p(struct part *restrict p) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &density_unpack_s->_wcount_dh;
}

/**
 * @brief get read-only access to pointer to wcount_dh,
 * Derivative of the neighbour number with respect to h.
 * If you need write access to wcount_dh, use part_get_wcount_dh_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_wcount_dh_p(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &density_unpack_s->_wcount_dh;
}

/**
 * @brief set the value of wcount_dh, Derivative of the neighbour number with respect to h.
 */
static __attribute__((always_inline)) INLINE void
  part_set_wcount_dh(struct part *restrict p, const float wcount_dh) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  density_unpack_s->_wcount_dh = wcount_dh;
}




/**
 * @brief get rot_v, Particle velocity curl,
 * for read and write access. For read-only access, use
 * part_get_const_rot_v() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_rot_v(struct part *restrict p) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return density_unpack_s->_rot_v;
}

/**
 * @brief get rot_v, Particle velocity curl, for read-only access.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_rot_v(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return density_unpack_s->_rot_v;
}

/**
 * @brief get rot_v, Particle velocity curl, by index.
 */
static __attribute__((always_inline)) INLINE float
  part_get_rot_v_ind(const struct part *restrict p, const size_t ind) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return density_unpack_s->_rot_v[ind];
}

/**
 * @brief set all values of rot_v, Particle velocity curl,
 * from an array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rot_v(struct part *restrict p, const float rot_v[3]) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  density_unpack_s->_rot_v[0] = rot_v[0];
  density_unpack_s->_rot_v[1] = rot_v[1];
  density_unpack_s->_rot_v[2] = rot_v[2];
}

/**
 * @brief set the value of rot_v, Particle velocity curl, by index.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rot_v_ind(struct part *restrict p, const size_t i, const float rot_v) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  density_unpack_s->_rot_v[i] = rot_v;
}




/**
 * @brief get div_v, Particle velocity divergence.
 */
static __attribute__((always_inline)) INLINE float
  part_get_div_v(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return density_unpack_s->_div_v;
}

/**
 * @brief get a pointer to div_v, Particle velocity divergence.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to div_v. If you need read-only access to div_v, use part_get_const_div_v_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_div_v_p(struct part *restrict p) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &density_unpack_s->_div_v;
}

/**
 * @brief get read-only access to pointer to div_v,
 * Particle velocity divergence.
 * If you need write access to div_v, use part_get_div_v_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_div_v_p(const struct part *restrict p) {
  const struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &density_unpack_s->_div_v;
}

/**
 * @brief set the value of div_v, Particle velocity divergence.
 */
static __attribute__((always_inline)) INLINE void
  part_set_div_v(struct part *restrict p, const float div_v) {
  struct density_unpack* density_unpack_s = p->_cell_part_arrays->_density_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(density_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", density_unpack_s->_accessor_id, p->_accessor_id);
#endif
  density_unpack_s->_div_v = div_v;
}






/**
 * @brief get a_hydro, Particle acceleration,
 * for read and write access. For read-only access, use
 * part_get_const_a_hydro() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_a_hydro(struct part *restrict p) {
  struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return force_unpack_s->_a_hydro;
}

/**
 * @brief get a_hydro, Particle acceleration, for read-only access.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_a_hydro(const struct part *restrict p) {
  const struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return force_unpack_s->_a_hydro;
}

/**
 * @brief get a_hydro, Particle acceleration, by index.
 */
static __attribute__((always_inline)) INLINE float
  part_get_a_hydro_ind(const struct part *restrict p, const size_t ind) {
  const struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return force_unpack_s->_a_hydro[ind];
}

/**
 * @brief set all values of a_hydro, Particle acceleration,
 * from an array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_a_hydro(struct part *restrict p, const float a_hydro[3]) {
  struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  force_unpack_s->_a_hydro[0] = a_hydro[0];
  force_unpack_s->_a_hydro[1] = a_hydro[1];
  force_unpack_s->_a_hydro[2] = a_hydro[2];
}

/**
 * @brief set the value of a_hydro, Particle acceleration, by index.
 */
static __attribute__((always_inline)) INLINE void
  part_set_a_hydro_ind(struct part *restrict p, const size_t i, const float a_hydro) {
  struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  force_unpack_s->_a_hydro[i] = a_hydro;
}




/**
 * @brief get u_dt, Time derivative of the internal energy.
 */
static __attribute__((always_inline)) INLINE float
  part_get_u_dt(const struct part *restrict p) {
  const struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return force_unpack_s->_u_dt;
}

/**
 * @brief get a pointer to u_dt, Time derivative of the internal energy.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to u_dt. If you need read-only access to u_dt, use part_get_const_u_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_u_dt_p(struct part *restrict p) {
  struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_unpack_s->_u_dt;
}

/**
 * @brief get read-only access to pointer to u_dt,
 * Time derivative of the internal energy.
 * If you need write access to u_dt, use part_get_u_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_u_dt_p(const struct part *restrict p) {
  const struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_unpack_s->_u_dt;
}

/**
 * @brief set the value of u_dt, Time derivative of the internal energy.
 */
static __attribute__((always_inline)) INLINE void
  part_set_u_dt(struct part *restrict p, const float u_dt) {
  struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  force_unpack_s->_u_dt = u_dt;
}




/**
 * @brief get h_dt, Time derivative of smoothing length.
 */
static __attribute__((always_inline)) INLINE float
  part_get_h_dt(const struct part *restrict p) {
  const struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return force_unpack_s->_h_dt;
}

/**
 * @brief get a pointer to h_dt, Time derivative of smoothing length.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to h_dt. If you need read-only access to h_dt, use part_get_const_h_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_h_dt_p(struct part *restrict p) {
  struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_unpack_s->_h_dt;
}

/**
 * @brief get read-only access to pointer to h_dt,
 * Time derivative of smoothing length.
 * If you need write access to h_dt, use part_get_h_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_h_dt_p(const struct part *restrict p) {
  const struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  return &force_unpack_s->_h_dt;
}

/**
 * @brief set the value of h_dt, Time derivative of smoothing length.
 */
static __attribute__((always_inline)) INLINE void
  part_set_h_dt(struct part *restrict p, const float h_dt) {
  struct force_unpack* force_unpack_s = p->_cell_part_arrays->_force_unpack + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(force_unpack_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", force_unpack_s->_accessor_id, p->_accessor_id);
#endif
  force_unpack_s->_h_dt = h_dt;
}






/**
 * @brief get div_v_dt, Time differential of velocity divergence.
 */
static __attribute__((always_inline)) INLINE float
  part_get_div_v_dt(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_div_v_dt;
}

/**
 * @brief get a pointer to div_v_dt, Time differential of velocity divergence.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to div_v_dt. If you need read-only access to div_v_dt, use part_get_const_div_v_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_div_v_dt_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_div_v_dt;
}

/**
 * @brief get read-only access to pointer to div_v_dt,
 * Time differential of velocity divergence.
 * If you need write access to div_v_dt, use part_get_div_v_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_div_v_dt_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_div_v_dt;
}

/**
 * @brief set the value of div_v_dt, Time differential of velocity divergence.
 */
static __attribute__((always_inline)) INLINE void
  part_set_div_v_dt(struct part *restrict p, const float div_v_dt) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_div_v_dt = div_v_dt;
}




/**
 * @brief get div_v_previous_step, Particle velocity divergence from previous step.
 */
static __attribute__((always_inline)) INLINE float
  part_get_div_v_previous_step(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_div_v_previous_step;
}

/**
 * @brief get a pointer to div_v_previous_step, Particle velocity divergence from previous step.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to div_v_previous_step. If you need read-only access to div_v_previous_step, use part_get_const_div_v_previous_step_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_div_v_previous_step_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_div_v_previous_step;
}

/**
 * @brief get read-only access to pointer to div_v_previous_step,
 * Particle velocity divergence from previous step.
 * If you need write access to div_v_previous_step, use part_get_div_v_previous_step_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_div_v_previous_step_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_div_v_previous_step;
}

/**
 * @brief set the value of div_v_previous_step, Particle velocity divergence from previous step.
 */
static __attribute__((always_inline)) INLINE void
  part_set_div_v_previous_step(struct part *restrict p, const float div_v_previous_step) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_div_v_previous_step = div_v_previous_step;
}




/**
 * @brief get id, Particle unique ID.
 */
static __attribute__((always_inline)) INLINE long long
  part_get_id(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_id;
}

/**
 * @brief get a pointer to id, Particle unique ID.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to id. If you need read-only access to id, use part_get_const_id_p() instead.
 */
static __attribute__((always_inline)) INLINE long long*
  part_get_id_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_id;
}

/**
 * @brief get read-only access to pointer to id,
 * Particle unique ID.
 * If you need write access to id, use part_get_id_p() instead.
 */
static __attribute__((always_inline)) INLINE const long long*
  part_get_const_id_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_id;
}

/**
 * @brief set the value of id, Particle unique ID.
 */
static __attribute__((always_inline)) INLINE void
  part_set_id(struct part *restrict p, const long long id) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_id = id;
}




/**
 * @brief get gpart, Pointer to corresponding gravity part.
 */
static __attribute__((always_inline)) INLINE struct gpart*
  part_get_gpart(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_gpart;
}

/**
 * @brief get a pointer to gpart, Pointer to corresponding gravity part.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to gpart. If you need read-only access to gpart, use part_get_const_gpart_p() instead.
 */
static __attribute__((always_inline)) INLINE struct gpart**
  part_get_gpart_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_gpart;
}/**
 * @brief set the value of gpart, Pointer to corresponding gravity part.
 */
static __attribute__((always_inline)) INLINE void
  part_set_gpart(struct part *restrict p,  struct gpart* gpart) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_gpart = gpart;
}




/**
 * @brief get adaptive_softening_data, Additional data used for adaptive softening.
 */
static __attribute__((always_inline)) INLINE struct adaptive_softening_part_data
  part_get_adaptive_softening_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_adaptive_softening_data;
}

/**
 * @brief get a pointer to adaptive_softening_data, Additional data used for adaptive softening.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to adaptive_softening_data. If you need read-only access to adaptive_softening_data, use part_get_const_adaptive_softening_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct adaptive_softening_part_data*
  part_get_adaptive_softening_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_adaptive_softening_data;
}

/**
 * @brief get read-only access to pointer to adaptive_softening_data,
 * Additional data used for adaptive softening.
 * If you need write access to adaptive_softening_data, use part_get_adaptive_softening_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct adaptive_softening_part_data*
  part_get_const_adaptive_softening_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_adaptive_softening_data;
}

/**
 * @brief set the value of adaptive_softening_data, Additional data used for adaptive softening.
 */
static __attribute__((always_inline)) INLINE void
  part_set_adaptive_softening_data(struct part *restrict p, const struct adaptive_softening_part_data adaptive_softening_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_adaptive_softening_data = adaptive_softening_data;
}




/**
 * @brief get mhd_data, Additional data used by the MHD scheme.
 */
static __attribute__((always_inline)) INLINE struct mhd_part_data
  part_get_mhd_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_mhd_data;
}

/**
 * @brief get a pointer to mhd_data, Additional data used by the MHD scheme.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to mhd_data. If you need read-only access to mhd_data, use part_get_const_mhd_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct mhd_part_data*
  part_get_mhd_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_mhd_data;
}

/**
 * @brief get read-only access to pointer to mhd_data,
 * Additional data used by the MHD scheme.
 * If you need write access to mhd_data, use part_get_mhd_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct mhd_part_data*
  part_get_const_mhd_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_mhd_data;
}

/**
 * @brief set the value of mhd_data, Additional data used by the MHD scheme.
 */
static __attribute__((always_inline)) INLINE void
  part_set_mhd_data(struct part *restrict p, const struct mhd_part_data mhd_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_mhd_data = mhd_data;
}




/**
 * @brief get chemistry_data, Chemistry information.
 */
static __attribute__((always_inline)) INLINE struct chemistry_part_data
  part_get_chemistry_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_chemistry_data;
}

/**
 * @brief get a pointer to chemistry_data, Chemistry information.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to chemistry_data. If you need read-only access to chemistry_data, use part_get_const_chemistry_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct chemistry_part_data*
  part_get_chemistry_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_chemistry_data;
}

/**
 * @brief get read-only access to pointer to chemistry_data,
 * Chemistry information.
 * If you need write access to chemistry_data, use part_get_chemistry_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct chemistry_part_data*
  part_get_const_chemistry_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_chemistry_data;
}

/**
 * @brief set the value of chemistry_data, Chemistry information.
 */
static __attribute__((always_inline)) INLINE void
  part_set_chemistry_data(struct part *restrict p, const struct chemistry_part_data chemistry_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_chemistry_data = chemistry_data;
}




/**
 * @brief get cooling_data, Cooling information.
 */
static __attribute__((always_inline)) INLINE struct cooling_part_data
  part_get_cooling_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_cooling_data;
}

/**
 * @brief get a pointer to cooling_data, Cooling information.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to cooling_data. If you need read-only access to cooling_data, use part_get_const_cooling_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct cooling_part_data*
  part_get_cooling_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_cooling_data;
}

/**
 * @brief get read-only access to pointer to cooling_data,
 * Cooling information.
 * If you need write access to cooling_data, use part_get_cooling_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct cooling_part_data*
  part_get_const_cooling_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_cooling_data;
}

/**
 * @brief set the value of cooling_data, Cooling information.
 */
static __attribute__((always_inline)) INLINE void
  part_set_cooling_data(struct part *restrict p, const struct cooling_part_data cooling_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_cooling_data = cooling_data;
}




/**
 * @brief get feedback_data, Additional data used by the feedback.
 */
static __attribute__((always_inline)) INLINE struct feedback_part_data
  part_get_feedback_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_feedback_data;
}

/**
 * @brief get a pointer to feedback_data, Additional data used by the feedback.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to feedback_data. If you need read-only access to feedback_data, use part_get_const_feedback_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct feedback_part_data*
  part_get_feedback_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_feedback_data;
}

/**
 * @brief get read-only access to pointer to feedback_data,
 * Additional data used by the feedback.
 * If you need write access to feedback_data, use part_get_feedback_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct feedback_part_data*
  part_get_const_feedback_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_feedback_data;
}

/**
 * @brief set the value of feedback_data, Additional data used by the feedback.
 */
static __attribute__((always_inline)) INLINE void
  part_set_feedback_data(struct part *restrict p, const struct feedback_part_data feedback_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_feedback_data = feedback_data;
}




/**
 * @brief get black_holes_data, Black holes information (eg swallowing ID).
 */
static __attribute__((always_inline)) INLINE struct black_holes_part_data
  part_get_black_holes_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_black_holes_data;
}

/**
 * @brief get a pointer to black_holes_data, Black holes information (eg swallowing ID).
 * Use this only if you need to modify the value, i.e. if you need write access
 * to black_holes_data. If you need read-only access to black_holes_data, use part_get_const_black_holes_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct black_holes_part_data*
  part_get_black_holes_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_black_holes_data;
}

/**
 * @brief get read-only access to pointer to black_holes_data,
 * Black holes information (eg swallowing ID).
 * If you need write access to black_holes_data, use part_get_black_holes_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct black_holes_part_data*
  part_get_const_black_holes_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_black_holes_data;
}

/**
 * @brief set the value of black_holes_data, Black holes information (eg swallowing ID).
 */
static __attribute__((always_inline)) INLINE void
  part_set_black_holes_data(struct part *restrict p, const struct black_holes_part_data black_holes_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_black_holes_data = black_holes_data;
}




/**
 * @brief get sink_data, Sink information (eg swallowing ID).
 */
static __attribute__((always_inline)) INLINE struct sink_part_data
  part_get_sink_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_sink_data;
}

/**
 * @brief get a pointer to sink_data, Sink information (eg swallowing ID).
 * Use this only if you need to modify the value, i.e. if you need write access
 * to sink_data. If you need read-only access to sink_data, use part_get_const_sink_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct sink_part_data*
  part_get_sink_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_sink_data;
}

/**
 * @brief get read-only access to pointer to sink_data,
 * Sink information (eg swallowing ID).
 * If you need write access to sink_data, use part_get_sink_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct sink_part_data*
  part_get_const_sink_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_sink_data;
}

/**
 * @brief set the value of sink_data, Sink information (eg swallowing ID).
 */
static __attribute__((always_inline)) INLINE void
  part_set_sink_data(struct part *restrict p, const struct sink_part_data sink_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_sink_data = sink_data;
}




/**
 * @brief get pressure_floor_data, Additional data used by the pressure floor.
 */
static __attribute__((always_inline)) INLINE struct pressure_floor_part_data
  part_get_pressure_floor_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_pressure_floor_data;
}

/**
 * @brief get a pointer to pressure_floor_data, Additional data used by the pressure floor.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to pressure_floor_data. If you need read-only access to pressure_floor_data, use part_get_const_pressure_floor_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct pressure_floor_part_data*
  part_get_pressure_floor_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_pressure_floor_data;
}

/**
 * @brief get read-only access to pointer to pressure_floor_data,
 * Additional data used by the pressure floor.
 * If you need write access to pressure_floor_data, use part_get_pressure_floor_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct pressure_floor_part_data*
  part_get_const_pressure_floor_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_pressure_floor_data;
}

/**
 * @brief set the value of pressure_floor_data, Additional data used by the pressure floor.
 */
static __attribute__((always_inline)) INLINE void
  part_set_pressure_floor_data(struct part *restrict p, const struct pressure_floor_part_data pressure_floor_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_pressure_floor_data = pressure_floor_data;
}




/**
 * @brief get rt_data, Additional Radiative Transfer Data.
 */
static __attribute__((always_inline)) INLINE struct rt_part_data
  part_get_rt_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_rt_data;
}

/**
 * @brief get a pointer to rt_data, Additional Radiative Transfer Data.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rt_data. If you need read-only access to rt_data, use part_get_const_rt_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct rt_part_data*
  part_get_rt_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_rt_data;
}

/**
 * @brief get read-only access to pointer to rt_data,
 * Additional Radiative Transfer Data.
 * If you need write access to rt_data, use part_get_rt_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct rt_part_data*
  part_get_const_rt_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_rt_data;
}

/**
 * @brief set the value of rt_data, Additional Radiative Transfer Data.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rt_data(struct part *restrict p, const struct rt_part_data rt_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_rt_data = rt_data;
}




/**
 * @brief get rt_time_data, RT sub-cycling time stepping data.
 */
static __attribute__((always_inline)) INLINE struct rt_timestepping_data
  part_get_rt_time_data(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_rt_time_data;
}

/**
 * @brief get a pointer to rt_time_data, RT sub-cycling time stepping data.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rt_time_data. If you need read-only access to rt_time_data, use part_get_const_rt_time_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct rt_timestepping_data*
  part_get_rt_time_data_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_rt_time_data;
}

/**
 * @brief get read-only access to pointer to rt_time_data,
 * RT sub-cycling time stepping data.
 * If you need write access to rt_time_data, use part_get_rt_time_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct rt_timestepping_data*
  part_get_const_rt_time_data_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_rt_time_data;
}

/**
 * @brief set the value of rt_time_data, RT sub-cycling time stepping data.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rt_time_data(struct part *restrict p, const struct rt_timestepping_data rt_time_data) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_rt_time_data = rt_time_data;
}




/**
 * @brief get depth_h, Tree-depth at which size / 2 <= h * gamma < size.
 */
static __attribute__((always_inline)) INLINE char
  part_get_depth_h(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_depth_h;
}

/**
 * @brief get a pointer to depth_h, Tree-depth at which size / 2 <= h * gamma < size.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to depth_h. If you need read-only access to depth_h, use part_get_const_depth_h_p() instead.
 */
static __attribute__((always_inline)) INLINE char*
  part_get_depth_h_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_depth_h;
}

/**
 * @brief get read-only access to pointer to depth_h,
 * Tree-depth at which size / 2 <= h * gamma < size.
 * If you need write access to depth_h, use part_get_depth_h_p() instead.
 */
static __attribute__((always_inline)) INLINE const char*
  part_get_const_depth_h_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_depth_h;
}

/**
 * @brief set the value of depth_h, Tree-depth at which size / 2 <= h * gamma < size.
 */
static __attribute__((always_inline)) INLINE void
  part_set_depth_h(struct part *restrict p, const char depth_h) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_depth_h = depth_h;
}




/**
 * @brief get ti_drift, Time of the last drift.
 */
static __attribute__((always_inline)) INLINE integertime_t
  part_get_ti_drift(const struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);

  return others_s->_ti_drift;
#else
  return LLONG_MAX;
#endif
}

/**
 * @brief get a pointer to ti_drift, Time of the last drift.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to ti_drift. If you need read-only access to ti_drift, use part_get_const_ti_drift_p() instead.
 */
static __attribute__((always_inline)) INLINE integertime_t*
  part_get_ti_drift_p(struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);

  return &others_s->_ti_drift;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to ti_drift,
 * Time of the last drift.
 * If you need write access to ti_drift, use part_get_ti_drift_p() instead.
 */
static __attribute__((always_inline)) INLINE const integertime_t*
  part_get_const_ti_drift_p(const struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);

  return &others_s->_ti_drift;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of ti_drift, Time of the last drift.
 */
static __attribute__((always_inline)) INLINE void
  part_set_ti_drift(struct part *restrict p, const integertime_t ti_drift) {
#ifdef SWIFT_DEBUG_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);

  others_s->_ti_drift = ti_drift;
#endif
}




/**
 * @brief get ti_kick, Time of the last drift.
 */
static __attribute__((always_inline)) INLINE integertime_t
  part_get_ti_kick(const struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);

  return others_s->_ti_kick;
#else
  return LLONG_MAX;
#endif
}

/**
 * @brief get a pointer to ti_kick, Time of the last drift.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to ti_kick. If you need read-only access to ti_kick, use part_get_const_ti_kick_p() instead.
 */
static __attribute__((always_inline)) INLINE integertime_t*
  part_get_ti_kick_p(struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);

  return &others_s->_ti_kick;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to ti_kick,
 * Time of the last drift.
 * If you need write access to ti_kick, use part_get_ti_kick_p() instead.
 */
static __attribute__((always_inline)) INLINE const integertime_t*
  part_get_const_ti_kick_p(const struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);

  return &others_s->_ti_kick;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of ti_kick, Time of the last drift.
 */
static __attribute__((always_inline)) INLINE void
  part_set_ti_kick(struct part *restrict p, const integertime_t ti_kick) {
#ifdef SWIFT_DEBUG_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);

  others_s->_ti_kick = ti_kick;
#endif
}




/**
 * @brief get N_density, Integer number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_density(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_N_density;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_density, Integer number of neighbours in the density loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_density. If you need read-only access to N_density, use part_get_const_N_density_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_density_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_density;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_density,
 * Integer number of neighbours in the density loop.
 * If you need write access to N_density, use part_get_N_density_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_density_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_density;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_density, Integer number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_density(struct part *restrict p, const int N_density) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_N_density = N_density;
#endif
}




/**
 * @brief get N_density_exact, Exact integer number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_density_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_N_density_exact;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_density_exact, Exact integer number of neighbours in the density loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_density_exact. If you need read-only access to N_density_exact, use part_get_const_N_density_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_density_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_density_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_density_exact,
 * Exact integer number of neighbours in the density loop.
 * If you need write access to N_density_exact, use part_get_N_density_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_density_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_density_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_density_exact, Exact integer number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_density_exact(struct part *restrict p, const int N_density_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_N_density_exact = N_density_exact;
#endif
}




/**
 * @brief get N_gradient, Integer number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_gradient(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_N_gradient;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_gradient, Integer number of neighbours in the gradient loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_gradient. If you need read-only access to N_gradient, use part_get_const_N_gradient_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_gradient_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_gradient;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_gradient,
 * Integer number of neighbours in the gradient loop.
 * If you need write access to N_gradient, use part_get_N_gradient_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_gradient_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_gradient;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_gradient, Integer number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_gradient(struct part *restrict p, const int N_gradient) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_N_gradient = N_gradient;
#endif
}




/**
 * @brief get N_gradient_exact, Exact integer number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_gradient_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_N_gradient_exact;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_gradient_exact, Exact integer number of neighbours in the gradient loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_gradient_exact. If you need read-only access to N_gradient_exact, use part_get_const_N_gradient_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_gradient_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_gradient_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_gradient_exact,
 * Exact integer number of neighbours in the gradient loop.
 * If you need write access to N_gradient_exact, use part_get_N_gradient_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_gradient_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_gradient_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_gradient_exact, Exact integer number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_gradient_exact(struct part *restrict p, const int N_gradient_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_N_gradient_exact = N_gradient_exact;
#endif
}




/**
 * @brief get N_force, Integer number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_force(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_N_force;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_force, Integer number of neighbours in the force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_force. If you need read-only access to N_force, use part_get_const_N_force_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_force_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_force;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_force,
 * Integer number of neighbours in the force loop.
 * If you need write access to N_force, use part_get_N_force_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_force_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_force;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_force, Integer number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_force(struct part *restrict p, const int N_force) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_N_force = N_force;
#endif
}




/**
 * @brief get N_force_exact, Exact integer number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_force_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_N_force_exact;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_force_exact, Exact integer number of neighbours in the force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_force_exact. If you need read-only access to N_force_exact, use part_get_const_N_force_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_force_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_force_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_force_exact,
 * Exact integer number of neighbours in the force loop.
 * If you need write access to N_force_exact, use part_get_N_force_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_force_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_N_force_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_force_exact, Exact integer number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_force_exact(struct part *restrict p, const int N_force_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_N_force_exact = N_force_exact;
#endif
}




/**
 * @brief get rho_exact, Exact value of the density field obtained via brute-force loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_rho_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_rho_exact;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to rho_exact, Exact value of the density field obtained via brute-force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rho_exact. If you need read-only access to rho_exact, use part_get_const_rho_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_rho_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_rho_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to rho_exact,
 * Exact value of the density field obtained via brute-force loop.
 * If you need write access to rho_exact, use part_get_rho_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_rho_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_rho_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of rho_exact, Exact value of the density field obtained via brute-force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rho_exact(struct part *restrict p, const float rho_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_rho_exact = rho_exact;
#endif
}




/**
 * @brief get n_density, Weighted number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_density(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_n_density;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_density, Weighted number of neighbours in the density loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_density. If you need read-only access to n_density, use part_get_const_n_density_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_density_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_density;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_density,
 * Weighted number of neighbours in the density loop.
 * If you need write access to n_density, use part_get_n_density_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_density_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_density;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_density, Weighted number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_density(struct part *restrict p, const float n_density) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_n_density = n_density;
#endif
}




/**
 * @brief get n_density_exact, Exact value of the weighted number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_density_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_n_density_exact;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_density_exact, Exact value of the weighted number of neighbours in the density loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_density_exact. If you need read-only access to n_density_exact, use part_get_const_n_density_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_density_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_density_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_density_exact,
 * Exact value of the weighted number of neighbours in the density loop.
 * If you need write access to n_density_exact, use part_get_n_density_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_density_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_density_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_density_exact, Exact value of the weighted number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_density_exact(struct part *restrict p, const float n_density_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_n_density_exact = n_density_exact;
#endif
}




/**
 * @brief get n_gradient, Weighted number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_gradient(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_n_gradient;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_gradient, Weighted number of neighbours in the gradient loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_gradient. If you need read-only access to n_gradient, use part_get_const_n_gradient_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_gradient_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_gradient;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_gradient,
 * Weighted number of neighbours in the gradient loop.
 * If you need write access to n_gradient, use part_get_n_gradient_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_gradient_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_gradient;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_gradient, Weighted number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_gradient(struct part *restrict p, const float n_gradient) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_n_gradient = n_gradient;
#endif
}




/**
 * @brief get n_gradient_exact, Exact value of the weighted number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_gradient_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_n_gradient_exact;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_gradient_exact, Exact value of the weighted number of neighbours in the gradient loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_gradient_exact. If you need read-only access to n_gradient_exact, use part_get_const_n_gradient_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_gradient_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_gradient_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_gradient_exact,
 * Exact value of the weighted number of neighbours in the gradient loop.
 * If you need write access to n_gradient_exact, use part_get_n_gradient_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_gradient_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_gradient_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_gradient_exact, Exact value of the weighted number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_gradient_exact(struct part *restrict p, const float n_gradient_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_n_gradient_exact = n_gradient_exact;
#endif
}




/**
 * @brief get n_force, Weighted number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_force(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_n_force;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_force, Weighted number of neighbours in the force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_force. If you need read-only access to n_force, use part_get_const_n_force_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_force_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_force;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_force,
 * Weighted number of neighbours in the force loop.
 * If you need write access to n_force, use part_get_n_force_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_force_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_force;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_force, Weighted number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_force(struct part *restrict p, const float n_force) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_n_force = n_force;
#endif
}




/**
 * @brief get n_force_exact, Exact value of the weighted number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_force_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_n_force_exact;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_force_exact, Exact value of the weighted number of neighbours in the force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_force_exact. If you need read-only access to n_force_exact, use part_get_const_n_force_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_force_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_force_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_force_exact,
 * Exact value of the weighted number of neighbours in the force loop.
 * If you need write access to n_force_exact, use part_get_n_force_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_force_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_n_force_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_force_exact, Exact value of the weighted number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_force_exact(struct part *restrict p, const float n_force_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_n_force_exact = n_force_exact;
#endif
}




/**
 * @brief get inhibited_exact, Has this particle interacted with any unhibited neighbour?.
 */
static __attribute__((always_inline)) INLINE char
  part_get_inhibited_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_inhibited_exact;
#else
  return CHAR_MAX;
#endif
}

/**
 * @brief get a pointer to inhibited_exact, Has this particle interacted with any unhibited neighbour?.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to inhibited_exact. If you need read-only access to inhibited_exact, use part_get_const_inhibited_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE char*
  part_get_inhibited_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_inhibited_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to inhibited_exact,
 * Has this particle interacted with any unhibited neighbour?.
 * If you need write access to inhibited_exact, use part_get_inhibited_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const char*
  part_get_const_inhibited_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_inhibited_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of inhibited_exact, Has this particle interacted with any unhibited neighbour?.
 */
static __attribute__((always_inline)) INLINE void
  part_set_inhibited_exact(struct part *restrict p, const char inhibited_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_inhibited_exact = inhibited_exact;
#endif
}




/**
 * @brief get limited_part, Has this particle been woken up by the limiter?.
 */
static __attribute__((always_inline)) INLINE char
  part_get_limited_part(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_limited_part;
#else
  return CHAR_MAX;
#endif
}

/**
 * @brief get a pointer to limited_part, Has this particle been woken up by the limiter?.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to limited_part. If you need read-only access to limited_part, use part_get_const_limited_part_p() instead.
 */
static __attribute__((always_inline)) INLINE char*
  part_get_limited_part_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_limited_part;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to limited_part,
 * Has this particle been woken up by the limiter?.
 * If you need write access to limited_part, use part_get_limited_part_p() instead.
 */
static __attribute__((always_inline)) INLINE const char*
  part_get_const_limited_part_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_limited_part;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of limited_part, Has this particle been woken up by the limiter?.
 */
static __attribute__((always_inline)) INLINE void
  part_set_limited_part(struct part *restrict p, const char limited_part) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_limited_part = limited_part;
#endif
}




/**
 * @brief get geometry, Geometrical quantities used for Finite Volume Particle Method RT.
 */
static __attribute__((always_inline)) INLINE struct fvpm_geometry_struct
  part_get_geometry(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return others_s->_geometry;
}

/**
 * @brief get a pointer to geometry, Geometrical quantities used for Finite Volume Particle Method RT.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to geometry. If you need read-only access to geometry, use part_get_const_geometry_p() instead.
 */
static __attribute__((always_inline)) INLINE struct fvpm_geometry_struct*
  part_get_geometry_p(struct part *restrict p) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_geometry;
}

/**
 * @brief get read-only access to pointer to geometry,
 * Geometrical quantities used for Finite Volume Particle Method RT.
 * If you need write access to geometry, use part_get_geometry_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct fvpm_geometry_struct*
  part_get_const_geometry_p(const struct part *restrict p) {
  const struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  return &others_s->_geometry;
}

/**
 * @brief set the value of geometry, Geometrical quantities used for Finite Volume Particle Method RT.
 */
static __attribute__((always_inline)) INLINE void
  part_set_geometry(struct part *restrict p, const struct fvpm_geometry_struct geometry) {
  struct others* others_s = p->_cell_part_arrays->_others + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(others_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", others_s->_accessor_id, p->_accessor_id);
#endif
  others_s->_geometry = geometry;
}







#endif /* SWIFT_HYDRO_PART_7950cb4e488e9b2bbe2cafc74745dc6bc0eeca11_H */
