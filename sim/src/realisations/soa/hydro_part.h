/**
  * WARNING: THIS FILE WAS GENERATED. MODIFICATIONS WILL NOT STICK.
  * File template is /home/mivkov/Durham/swiftgpupacksim/py/templates/hydro_part.h.jinja.template
  */


#ifndef SWIFT_HYDRO_PART_45f18804078753c6002db4c09d1e7203629af930_H
#define SWIFT_HYDRO_PART_45f18804078753c6002db4c09d1e7203629af930_H

 

#include "align.h"
#include "error.h"
#include "hydro_part_placeholder_structs.h"
#include "hydro_part_arrays_struct.h"
#include "rt_struct.h"
#include "timestep_limiter_struct.h"

#include <float.h>
#include <limits.h>
#include <stddef.h>


struct part {
  /*! offset/index of particle in cell particle data array */
  size_t _cell_offset;

  /*! pointer to particle data array struct of the cell this particle is located in */
  struct hydro_part_arrays* _cell_part_arrays;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_id {
  /*! Particle unique ID */
  long long _id;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_gpart {
  /*! Pointer to corresponding gravity part */
  struct gpart* _gpart;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_x {
  /*! the particle position */
  double _x[3];

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_v {
  /*! Particle predicted velocity */
  float _v[3];

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_a_hydro {
  /*! Particle acceleration */
  float _a_hydro[3];

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_mass {
  /*! Particle mass */
  float _mass;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_h {
  /*! Particle smoothing length */
  float _h;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_u {
  /*! Particle internal energy */
  float _u;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_u_dt {
  /*! Time derivative of the internal energy */
  float _u_dt;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_rho {
  /*! Particle density */
  float _rho;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_div_v {
  /*! Particle velocity divergence */
  float _div_v;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_div_v_dt {
  /*! Time differential of velocity divergence */
  float _div_v_dt;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_div_v_previous_step {
  /*! Particle velocity divergence from previous step */
  float _div_v_previous_step;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_alpha_av {
  /*! Artificial viscosity parameter */
  float _alpha_av;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_v_sig {
  /*! Signal velocity */
  float _v_sig;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_laplace_u {
  /*! del^2 u, a smoothed quantity */
  float _laplace_u;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_alpha_diff {
  /*! Thermal diffusion coefficient */
  float _alpha_diff;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_density_force1 {
  union {

    /*! Neighbour number count */
    float _wcount;

    /*! 'Grad h' term -- only partial in P-U */
    float _f_gradh;

   };

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_density_force2 {
  union {

    /*! Derivative of the neighbour number with respect to h */
    float _wcount_dh;

    /*! Particle pressure */
    float _pressure;

   };

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_density_force3 {
  union {

    /*! Derivative of density with respect to h */
    float _rho_dh;

    /*! Particle soundspeed */
    float _soundspeed;

   };

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_density_force4 {
  union {

    /*! Particle velocity curl */
    float _rot_v[3];

    /*! remaining force quantities to fill this union */
    struct {

      /*! Time derivative of smoothing length */
      float _h_dt;

      /*! Balsara switch */
      float _balsara;

      /*! Maximal alpha (viscosity) over neighbours */
      float _alpha_visc_max_ngb;

     }_force;

   };

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_additional_structs {
  /*! Additional data used for adaptive softening */
  struct adaptive_softening_part_data _adaptive_softening_data;

  /*! Additional data used by the MHD scheme */
  struct mhd_part_data _mhd_data;

  /*! Chemistry information */
  struct chemistry_part_data _chemistry_data;

  /*! Cooling information */
  struct cooling_part_data _cooling_data;

  /*! Additional data used by the feedback */
  struct feedback_part_data _feedback_data;

  /*! Black holes information (eg swallowing ID) */
  struct black_holes_part_data _black_holes_data;

  /*! Sink information (eg swallowing ID) */
  struct sink_part_data _sink_data;

  /*! Additional data used by the pressure floor */
  struct pressure_floor_part_data _pressure_floor_data;

  /*! Geometrical quantities used for Finite Volume Particle Method RT */
  struct fvpm_geometry_struct _geometry;

  /*! Additional Radiative Transfer Data */
  struct rt_part_data _rt_data;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_rt_time_data {
  /*! RT sub-cycling time stepping data */
  struct rt_timestepping_data _rt_time_data;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_depth_h {
  /*! Tree-depth at which size / 2 <= h * gamma < size */
  char _depth_h;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_time_bin {
  /*! Time-step length */
  timebin_t _time_bin;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_limiter_data {
  /*! Time-step limiter information */
  struct timestep_limiter_data _limiter_data;

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_ti_drift {
#ifdef SWIFT_DEBUG_CHECKS
  /*! Time of the last drift */
  integertime_t _ti_drift;
#endif

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_ti_kick {
#ifdef SWIFT_DEBUG_CHECKS
  /*! Time of the last drift */
  integertime_t _ti_kick;
#endif

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;

struct part_debugging {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Integer number of neighbours in the density loop */
  int _N_density;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact integer number of neighbours in the density loop */
  int _N_density_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Integer number of neighbours in the gradient loop */
  int _N_gradient;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact integer number of neighbours in the gradient loop */
  int _N_gradient_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Integer number of neighbours in the force loop */
  int _N_force;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact integer number of neighbours in the force loop */
  int _N_force_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact value of the density field obtained via brute-force loop */
  float _rho_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Weighted number of neighbours in the density loop */
  float _n_density;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact value of the weighted number of neighbours in the density loop */
  float _n_density_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Weighted number of neighbours in the gradient loop */
  float _n_gradient;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact value of the weighted number of neighbours in the gradient loop */
  float _n_gradient_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Weighted number of neighbours in the force loop */
  float _n_force;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Exact value of the weighted number of neighbours in the force loop */
  float _n_force_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Has this particle interacted with any unhibited neighbour? */
  char _inhibited_exact;
#endif

#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  /*! Has this particle been woken up by the limiter? */
  char _limited_part;
#endif

#ifdef SWIFT_DEBUG_CHECKS
  /*! This particle's accessor ID, identical for all structs associated with this particle. */
  long long _accessor_id;
#endif

} SWIFT_STRUCT_ALIGN;


/**
 * @brief get cell_offset, offset/index of particle in cell particle data array.
 */
static __attribute__((always_inline)) INLINE size_t
  part_get_cell_offset(const struct part *restrict p) {
  return p->_cell_offset;
}

/**
 * @brief get a pointer to cell_offset, offset/index of particle in cell particle data array.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to cell_offset. If you need read-only access to cell_offset, use part_get_const_cell_offset_p() instead.
 */
static __attribute__((always_inline)) INLINE size_t*
  part_get_cell_offset_p(struct part *restrict p) {
  return &p->_cell_offset;
}

/**
 * @brief get read-only access to pointer to cell_offset,
 * offset/index of particle in cell particle data array.
 * If you need write access to cell_offset, use part_get_cell_offset_p() instead.
 */
static __attribute__((always_inline)) INLINE const size_t*
  part_get_const_cell_offset_p(const struct part *restrict p) {
  return &p->_cell_offset;
}

/**
 * @brief set the value of cell_offset, offset/index of particle in cell particle data array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_cell_offset(struct part *restrict p, const size_t cell_offset) {
  p->_cell_offset = cell_offset;
}




/**
 * @brief get cell_part_arrays, pointer to particle data array struct of the cell this particle is located in.
 */
static __attribute__((always_inline)) INLINE struct hydro_part_arrays*
  part_get_cell_part_arrays(const struct part *restrict p) {
  return p->_cell_part_arrays;
}

/**
 * @brief get a pointer to cell_part_arrays, pointer to particle data array struct of the cell this particle is located in.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to cell_part_arrays. If you need read-only access to cell_part_arrays, use part_get_const_cell_part_arrays_p() instead.
 */
static __attribute__((always_inline)) INLINE struct hydro_part_arrays**
  part_get_cell_part_arrays_p(struct part *restrict p) {
  return &p->_cell_part_arrays;
}/**
 * @brief set the value of cell_part_arrays, pointer to particle data array struct of the cell this particle is located in.
 */
static __attribute__((always_inline)) INLINE void
  part_set_cell_part_arrays(struct part *restrict p,  struct hydro_part_arrays* cell_part_arrays) {
  p->_cell_part_arrays = cell_part_arrays;
}






/**
 * @brief get id, Particle unique ID.
 */
static __attribute__((always_inline)) INLINE long long
  part_get_id(const struct part *restrict p) {
  const struct part_id* part_id_s = p->_cell_part_arrays->_part_id + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_id_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_id_s->_accessor_id, p->_accessor_id);
#endif
  return part_id_s->_id;
}

/**
 * @brief get a pointer to id, Particle unique ID.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to id. If you need read-only access to id, use part_get_const_id_p() instead.
 */
static __attribute__((always_inline)) INLINE long long*
  part_get_id_p(struct part *restrict p) {
  struct part_id* part_id_s = p->_cell_part_arrays->_part_id + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_id_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_id_s->_accessor_id, p->_accessor_id);
#endif
  return &part_id_s->_id;
}

/**
 * @brief get read-only access to pointer to id,
 * Particle unique ID.
 * If you need write access to id, use part_get_id_p() instead.
 */
static __attribute__((always_inline)) INLINE const long long*
  part_get_const_id_p(const struct part *restrict p) {
  const struct part_id* part_id_s = p->_cell_part_arrays->_part_id + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_id_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_id_s->_accessor_id, p->_accessor_id);
#endif
  return &part_id_s->_id;
}

/**
 * @brief set the value of id, Particle unique ID.
 */
static __attribute__((always_inline)) INLINE void
  part_set_id(struct part *restrict p, const long long id) {
  struct part_id* part_id_s = p->_cell_part_arrays->_part_id + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_id_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_id_s->_accessor_id, p->_accessor_id);
#endif
  part_id_s->_id = id;
}






/**
 * @brief get gpart, Pointer to corresponding gravity part.
 */
static __attribute__((always_inline)) INLINE struct gpart*
  part_get_gpart(const struct part *restrict p) {
  const struct part_gpart* part_gpart_s = p->_cell_part_arrays->_part_gpart + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_gpart_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_gpart_s->_accessor_id, p->_accessor_id);
#endif
  return part_gpart_s->_gpart;
}

/**
 * @brief get a pointer to gpart, Pointer to corresponding gravity part.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to gpart. If you need read-only access to gpart, use part_get_const_gpart_p() instead.
 */
static __attribute__((always_inline)) INLINE struct gpart**
  part_get_gpart_p(struct part *restrict p) {
  struct part_gpart* part_gpart_s = p->_cell_part_arrays->_part_gpart + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_gpart_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_gpart_s->_accessor_id, p->_accessor_id);
#endif
  return &part_gpart_s->_gpart;
}/**
 * @brief set the value of gpart, Pointer to corresponding gravity part.
 */
static __attribute__((always_inline)) INLINE void
  part_set_gpart(struct part *restrict p,  struct gpart* gpart) {
  struct part_gpart* part_gpart_s = p->_cell_part_arrays->_part_gpart + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_gpart_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_gpart_s->_accessor_id, p->_accessor_id);
#endif
  part_gpart_s->_gpart = gpart;
}






/**
 * @brief get x, the particle position,
 * for read and write access. For read-only access, use
 * part_get_const_x() instead.
 */
static __attribute__((always_inline)) INLINE double*
  part_get_x(struct part *restrict p) {
  struct part_x* part_x_s = p->_cell_part_arrays->_part_x + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_x_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_x_s->_accessor_id, p->_accessor_id);
#endif
  return part_x_s->_x;
}

/**
 * @brief get x, the particle position, for read-only access.
 */
static __attribute__((always_inline)) INLINE const double*
  part_get_const_x(const struct part *restrict p) {
  const struct part_x* part_x_s = p->_cell_part_arrays->_part_x + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_x_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_x_s->_accessor_id, p->_accessor_id);
#endif
  return part_x_s->_x;
}

/**
 * @brief get x, the particle position, by index.
 */
static __attribute__((always_inline)) INLINE double
  part_get_x_ind(const struct part *restrict p, const size_t ind) {
  const struct part_x* part_x_s = p->_cell_part_arrays->_part_x + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_x_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_x_s->_accessor_id, p->_accessor_id);
#endif
  return part_x_s->_x[ind];
}

/**
 * @brief set all values of x, the particle position,
 * from an array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_x(struct part *restrict p, const double x[3]) {
  struct part_x* part_x_s = p->_cell_part_arrays->_part_x + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_x_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_x_s->_accessor_id, p->_accessor_id);
#endif
  part_x_s->_x[0] = x[0];
  part_x_s->_x[1] = x[1];
  part_x_s->_x[2] = x[2];
}

/**
 * @brief set the value of x, the particle position, by index.
 */
static __attribute__((always_inline)) INLINE void
  part_set_x_ind(struct part *restrict p, const size_t i, const double x) {
  struct part_x* part_x_s = p->_cell_part_arrays->_part_x + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_x_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_x_s->_accessor_id, p->_accessor_id);
#endif
  part_x_s->_x[i] = x;
}






/**
 * @brief get v, Particle predicted velocity,
 * for read and write access. For read-only access, use
 * part_get_const_v() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_v(struct part *restrict p) {
  struct part_v* part_v_s = p->_cell_part_arrays->_part_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_s->_accessor_id, p->_accessor_id);
#endif
  return part_v_s->_v;
}

/**
 * @brief get v, Particle predicted velocity, for read-only access.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_v(const struct part *restrict p) {
  const struct part_v* part_v_s = p->_cell_part_arrays->_part_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_s->_accessor_id, p->_accessor_id);
#endif
  return part_v_s->_v;
}

/**
 * @brief get v, Particle predicted velocity, by index.
 */
static __attribute__((always_inline)) INLINE float
  part_get_v_ind(const struct part *restrict p, const size_t ind) {
  const struct part_v* part_v_s = p->_cell_part_arrays->_part_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_s->_accessor_id, p->_accessor_id);
#endif
  return part_v_s->_v[ind];
}

/**
 * @brief set all values of v, Particle predicted velocity,
 * from an array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_v(struct part *restrict p, const float v[3]) {
  struct part_v* part_v_s = p->_cell_part_arrays->_part_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_s->_accessor_id, p->_accessor_id);
#endif
  part_v_s->_v[0] = v[0];
  part_v_s->_v[1] = v[1];
  part_v_s->_v[2] = v[2];
}

/**
 * @brief set the value of v, Particle predicted velocity, by index.
 */
static __attribute__((always_inline)) INLINE void
  part_set_v_ind(struct part *restrict p, const size_t i, const float v) {
  struct part_v* part_v_s = p->_cell_part_arrays->_part_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_s->_accessor_id, p->_accessor_id);
#endif
  part_v_s->_v[i] = v;
}






/**
 * @brief get a_hydro, Particle acceleration,
 * for read and write access. For read-only access, use
 * part_get_const_a_hydro() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_a_hydro(struct part *restrict p) {
  struct part_a_hydro* part_a_hydro_s = p->_cell_part_arrays->_part_a_hydro + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_a_hydro_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_a_hydro_s->_accessor_id, p->_accessor_id);
#endif
  return part_a_hydro_s->_a_hydro;
}

/**
 * @brief get a_hydro, Particle acceleration, for read-only access.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_a_hydro(const struct part *restrict p) {
  const struct part_a_hydro* part_a_hydro_s = p->_cell_part_arrays->_part_a_hydro + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_a_hydro_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_a_hydro_s->_accessor_id, p->_accessor_id);
#endif
  return part_a_hydro_s->_a_hydro;
}

/**
 * @brief get a_hydro, Particle acceleration, by index.
 */
static __attribute__((always_inline)) INLINE float
  part_get_a_hydro_ind(const struct part *restrict p, const size_t ind) {
  const struct part_a_hydro* part_a_hydro_s = p->_cell_part_arrays->_part_a_hydro + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_a_hydro_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_a_hydro_s->_accessor_id, p->_accessor_id);
#endif
  return part_a_hydro_s->_a_hydro[ind];
}

/**
 * @brief set all values of a_hydro, Particle acceleration,
 * from an array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_a_hydro(struct part *restrict p, const float a_hydro[3]) {
  struct part_a_hydro* part_a_hydro_s = p->_cell_part_arrays->_part_a_hydro + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_a_hydro_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_a_hydro_s->_accessor_id, p->_accessor_id);
#endif
  part_a_hydro_s->_a_hydro[0] = a_hydro[0];
  part_a_hydro_s->_a_hydro[1] = a_hydro[1];
  part_a_hydro_s->_a_hydro[2] = a_hydro[2];
}

/**
 * @brief set the value of a_hydro, Particle acceleration, by index.
 */
static __attribute__((always_inline)) INLINE void
  part_set_a_hydro_ind(struct part *restrict p, const size_t i, const float a_hydro) {
  struct part_a_hydro* part_a_hydro_s = p->_cell_part_arrays->_part_a_hydro + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_a_hydro_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_a_hydro_s->_accessor_id, p->_accessor_id);
#endif
  part_a_hydro_s->_a_hydro[i] = a_hydro;
}






/**
 * @brief get mass, Particle mass.
 */
static __attribute__((always_inline)) INLINE float
  part_get_mass(const struct part *restrict p) {
  const struct part_mass* part_mass_s = p->_cell_part_arrays->_part_mass + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_mass_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_mass_s->_accessor_id, p->_accessor_id);
#endif
  return part_mass_s->_mass;
}

/**
 * @brief get a pointer to mass, Particle mass.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to mass. If you need read-only access to mass, use part_get_const_mass_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_mass_p(struct part *restrict p) {
  struct part_mass* part_mass_s = p->_cell_part_arrays->_part_mass + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_mass_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_mass_s->_accessor_id, p->_accessor_id);
#endif
  return &part_mass_s->_mass;
}

/**
 * @brief get read-only access to pointer to mass,
 * Particle mass.
 * If you need write access to mass, use part_get_mass_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_mass_p(const struct part *restrict p) {
  const struct part_mass* part_mass_s = p->_cell_part_arrays->_part_mass + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_mass_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_mass_s->_accessor_id, p->_accessor_id);
#endif
  return &part_mass_s->_mass;
}

/**
 * @brief set the value of mass, Particle mass.
 */
static __attribute__((always_inline)) INLINE void
  part_set_mass(struct part *restrict p, const float mass) {
  struct part_mass* part_mass_s = p->_cell_part_arrays->_part_mass + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_mass_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_mass_s->_accessor_id, p->_accessor_id);
#endif
  part_mass_s->_mass = mass;
}






/**
 * @brief get h, Particle smoothing length.
 */
static __attribute__((always_inline)) INLINE float
  part_get_h(const struct part *restrict p) {
  const struct part_h* part_h_s = p->_cell_part_arrays->_part_h + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_h_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_h_s->_accessor_id, p->_accessor_id);
#endif
  return part_h_s->_h;
}

/**
 * @brief get a pointer to h, Particle smoothing length.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to h. If you need read-only access to h, use part_get_const_h_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_h_p(struct part *restrict p) {
  struct part_h* part_h_s = p->_cell_part_arrays->_part_h + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_h_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_h_s->_accessor_id, p->_accessor_id);
#endif
  return &part_h_s->_h;
}

/**
 * @brief get read-only access to pointer to h,
 * Particle smoothing length.
 * If you need write access to h, use part_get_h_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_h_p(const struct part *restrict p) {
  const struct part_h* part_h_s = p->_cell_part_arrays->_part_h + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_h_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_h_s->_accessor_id, p->_accessor_id);
#endif
  return &part_h_s->_h;
}

/**
 * @brief set the value of h, Particle smoothing length.
 */
static __attribute__((always_inline)) INLINE void
  part_set_h(struct part *restrict p, const float h) {
  struct part_h* part_h_s = p->_cell_part_arrays->_part_h + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_h_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_h_s->_accessor_id, p->_accessor_id);
#endif
  part_h_s->_h = h;
}






/**
 * @brief get u, Particle internal energy.
 */
static __attribute__((always_inline)) INLINE float
  part_get_u(const struct part *restrict p) {
  const struct part_u* part_u_s = p->_cell_part_arrays->_part_u + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_u_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_u_s->_accessor_id, p->_accessor_id);
#endif
  return part_u_s->_u;
}

/**
 * @brief get a pointer to u, Particle internal energy.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to u. If you need read-only access to u, use part_get_const_u_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_u_p(struct part *restrict p) {
  struct part_u* part_u_s = p->_cell_part_arrays->_part_u + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_u_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_u_s->_accessor_id, p->_accessor_id);
#endif
  return &part_u_s->_u;
}

/**
 * @brief get read-only access to pointer to u,
 * Particle internal energy.
 * If you need write access to u, use part_get_u_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_u_p(const struct part *restrict p) {
  const struct part_u* part_u_s = p->_cell_part_arrays->_part_u + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_u_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_u_s->_accessor_id, p->_accessor_id);
#endif
  return &part_u_s->_u;
}

/**
 * @brief set the value of u, Particle internal energy.
 */
static __attribute__((always_inline)) INLINE void
  part_set_u(struct part *restrict p, const float u) {
  struct part_u* part_u_s = p->_cell_part_arrays->_part_u + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_u_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_u_s->_accessor_id, p->_accessor_id);
#endif
  part_u_s->_u = u;
}






/**
 * @brief get u_dt, Time derivative of the internal energy.
 */
static __attribute__((always_inline)) INLINE float
  part_get_u_dt(const struct part *restrict p) {
  const struct part_u_dt* part_u_dt_s = p->_cell_part_arrays->_part_u_dt + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_u_dt_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_u_dt_s->_accessor_id, p->_accessor_id);
#endif
  return part_u_dt_s->_u_dt;
}

/**
 * @brief get a pointer to u_dt, Time derivative of the internal energy.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to u_dt. If you need read-only access to u_dt, use part_get_const_u_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_u_dt_p(struct part *restrict p) {
  struct part_u_dt* part_u_dt_s = p->_cell_part_arrays->_part_u_dt + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_u_dt_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_u_dt_s->_accessor_id, p->_accessor_id);
#endif
  return &part_u_dt_s->_u_dt;
}

/**
 * @brief get read-only access to pointer to u_dt,
 * Time derivative of the internal energy.
 * If you need write access to u_dt, use part_get_u_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_u_dt_p(const struct part *restrict p) {
  const struct part_u_dt* part_u_dt_s = p->_cell_part_arrays->_part_u_dt + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_u_dt_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_u_dt_s->_accessor_id, p->_accessor_id);
#endif
  return &part_u_dt_s->_u_dt;
}

/**
 * @brief set the value of u_dt, Time derivative of the internal energy.
 */
static __attribute__((always_inline)) INLINE void
  part_set_u_dt(struct part *restrict p, const float u_dt) {
  struct part_u_dt* part_u_dt_s = p->_cell_part_arrays->_part_u_dt + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_u_dt_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_u_dt_s->_accessor_id, p->_accessor_id);
#endif
  part_u_dt_s->_u_dt = u_dt;
}






/**
 * @brief get rho, Particle density.
 */
static __attribute__((always_inline)) INLINE float
  part_get_rho(const struct part *restrict p) {
  const struct part_rho* part_rho_s = p->_cell_part_arrays->_part_rho + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_rho_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_rho_s->_accessor_id, p->_accessor_id);
#endif
  return part_rho_s->_rho;
}

/**
 * @brief get a pointer to rho, Particle density.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rho. If you need read-only access to rho, use part_get_const_rho_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_rho_p(struct part *restrict p) {
  struct part_rho* part_rho_s = p->_cell_part_arrays->_part_rho + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_rho_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_rho_s->_accessor_id, p->_accessor_id);
#endif
  return &part_rho_s->_rho;
}

/**
 * @brief get read-only access to pointer to rho,
 * Particle density.
 * If you need write access to rho, use part_get_rho_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_rho_p(const struct part *restrict p) {
  const struct part_rho* part_rho_s = p->_cell_part_arrays->_part_rho + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_rho_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_rho_s->_accessor_id, p->_accessor_id);
#endif
  return &part_rho_s->_rho;
}

/**
 * @brief set the value of rho, Particle density.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rho(struct part *restrict p, const float rho) {
  struct part_rho* part_rho_s = p->_cell_part_arrays->_part_rho + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_rho_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_rho_s->_accessor_id, p->_accessor_id);
#endif
  part_rho_s->_rho = rho;
}






/**
 * @brief get div_v, Particle velocity divergence.
 */
static __attribute__((always_inline)) INLINE float
  part_get_div_v(const struct part *restrict p) {
  const struct part_div_v* part_div_v_s = p->_cell_part_arrays->_part_div_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_s->_accessor_id, p->_accessor_id);
#endif
  return part_div_v_s->_div_v;
}

/**
 * @brief get a pointer to div_v, Particle velocity divergence.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to div_v. If you need read-only access to div_v, use part_get_const_div_v_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_div_v_p(struct part *restrict p) {
  struct part_div_v* part_div_v_s = p->_cell_part_arrays->_part_div_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_s->_accessor_id, p->_accessor_id);
#endif
  return &part_div_v_s->_div_v;
}

/**
 * @brief get read-only access to pointer to div_v,
 * Particle velocity divergence.
 * If you need write access to div_v, use part_get_div_v_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_div_v_p(const struct part *restrict p) {
  const struct part_div_v* part_div_v_s = p->_cell_part_arrays->_part_div_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_s->_accessor_id, p->_accessor_id);
#endif
  return &part_div_v_s->_div_v;
}

/**
 * @brief set the value of div_v, Particle velocity divergence.
 */
static __attribute__((always_inline)) INLINE void
  part_set_div_v(struct part *restrict p, const float div_v) {
  struct part_div_v* part_div_v_s = p->_cell_part_arrays->_part_div_v + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_s->_accessor_id, p->_accessor_id);
#endif
  part_div_v_s->_div_v = div_v;
}






/**
 * @brief get div_v_dt, Time differential of velocity divergence.
 */
static __attribute__((always_inline)) INLINE float
  part_get_div_v_dt(const struct part *restrict p) {
  const struct part_div_v_dt* part_div_v_dt_s = p->_cell_part_arrays->_part_div_v_dt + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_dt_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_dt_s->_accessor_id, p->_accessor_id);
#endif
  return part_div_v_dt_s->_div_v_dt;
}

/**
 * @brief get a pointer to div_v_dt, Time differential of velocity divergence.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to div_v_dt. If you need read-only access to div_v_dt, use part_get_const_div_v_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_div_v_dt_p(struct part *restrict p) {
  struct part_div_v_dt* part_div_v_dt_s = p->_cell_part_arrays->_part_div_v_dt + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_dt_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_dt_s->_accessor_id, p->_accessor_id);
#endif
  return &part_div_v_dt_s->_div_v_dt;
}

/**
 * @brief get read-only access to pointer to div_v_dt,
 * Time differential of velocity divergence.
 * If you need write access to div_v_dt, use part_get_div_v_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_div_v_dt_p(const struct part *restrict p) {
  const struct part_div_v_dt* part_div_v_dt_s = p->_cell_part_arrays->_part_div_v_dt + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_dt_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_dt_s->_accessor_id, p->_accessor_id);
#endif
  return &part_div_v_dt_s->_div_v_dt;
}

/**
 * @brief set the value of div_v_dt, Time differential of velocity divergence.
 */
static __attribute__((always_inline)) INLINE void
  part_set_div_v_dt(struct part *restrict p, const float div_v_dt) {
  struct part_div_v_dt* part_div_v_dt_s = p->_cell_part_arrays->_part_div_v_dt + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_dt_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_dt_s->_accessor_id, p->_accessor_id);
#endif
  part_div_v_dt_s->_div_v_dt = div_v_dt;
}






/**
 * @brief get div_v_previous_step, Particle velocity divergence from previous step.
 */
static __attribute__((always_inline)) INLINE float
  part_get_div_v_previous_step(const struct part *restrict p) {
  const struct part_div_v_previous_step* part_div_v_previous_step_s = p->_cell_part_arrays->_part_div_v_previous_step + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_previous_step_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_previous_step_s->_accessor_id, p->_accessor_id);
#endif
  return part_div_v_previous_step_s->_div_v_previous_step;
}

/**
 * @brief get a pointer to div_v_previous_step, Particle velocity divergence from previous step.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to div_v_previous_step. If you need read-only access to div_v_previous_step, use part_get_const_div_v_previous_step_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_div_v_previous_step_p(struct part *restrict p) {
  struct part_div_v_previous_step* part_div_v_previous_step_s = p->_cell_part_arrays->_part_div_v_previous_step + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_previous_step_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_previous_step_s->_accessor_id, p->_accessor_id);
#endif
  return &part_div_v_previous_step_s->_div_v_previous_step;
}

/**
 * @brief get read-only access to pointer to div_v_previous_step,
 * Particle velocity divergence from previous step.
 * If you need write access to div_v_previous_step, use part_get_div_v_previous_step_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_div_v_previous_step_p(const struct part *restrict p) {
  const struct part_div_v_previous_step* part_div_v_previous_step_s = p->_cell_part_arrays->_part_div_v_previous_step + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_previous_step_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_previous_step_s->_accessor_id, p->_accessor_id);
#endif
  return &part_div_v_previous_step_s->_div_v_previous_step;
}

/**
 * @brief set the value of div_v_previous_step, Particle velocity divergence from previous step.
 */
static __attribute__((always_inline)) INLINE void
  part_set_div_v_previous_step(struct part *restrict p, const float div_v_previous_step) {
  struct part_div_v_previous_step* part_div_v_previous_step_s = p->_cell_part_arrays->_part_div_v_previous_step + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_div_v_previous_step_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_div_v_previous_step_s->_accessor_id, p->_accessor_id);
#endif
  part_div_v_previous_step_s->_div_v_previous_step = div_v_previous_step;
}






/**
 * @brief get alpha_av, Artificial viscosity parameter.
 */
static __attribute__((always_inline)) INLINE float
  part_get_alpha_av(const struct part *restrict p) {
  const struct part_alpha_av* part_alpha_av_s = p->_cell_part_arrays->_part_alpha_av + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_alpha_av_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_alpha_av_s->_accessor_id, p->_accessor_id);
#endif
  return part_alpha_av_s->_alpha_av;
}

/**
 * @brief get a pointer to alpha_av, Artificial viscosity parameter.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to alpha_av. If you need read-only access to alpha_av, use part_get_const_alpha_av_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_alpha_av_p(struct part *restrict p) {
  struct part_alpha_av* part_alpha_av_s = p->_cell_part_arrays->_part_alpha_av + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_alpha_av_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_alpha_av_s->_accessor_id, p->_accessor_id);
#endif
  return &part_alpha_av_s->_alpha_av;
}

/**
 * @brief get read-only access to pointer to alpha_av,
 * Artificial viscosity parameter.
 * If you need write access to alpha_av, use part_get_alpha_av_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_alpha_av_p(const struct part *restrict p) {
  const struct part_alpha_av* part_alpha_av_s = p->_cell_part_arrays->_part_alpha_av + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_alpha_av_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_alpha_av_s->_accessor_id, p->_accessor_id);
#endif
  return &part_alpha_av_s->_alpha_av;
}

/**
 * @brief set the value of alpha_av, Artificial viscosity parameter.
 */
static __attribute__((always_inline)) INLINE void
  part_set_alpha_av(struct part *restrict p, const float alpha_av) {
  struct part_alpha_av* part_alpha_av_s = p->_cell_part_arrays->_part_alpha_av + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_alpha_av_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_alpha_av_s->_accessor_id, p->_accessor_id);
#endif
  part_alpha_av_s->_alpha_av = alpha_av;
}






/**
 * @brief get v_sig, Signal velocity.
 */
static __attribute__((always_inline)) INLINE float
  part_get_v_sig(const struct part *restrict p) {
  const struct part_v_sig* part_v_sig_s = p->_cell_part_arrays->_part_v_sig + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_sig_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_sig_s->_accessor_id, p->_accessor_id);
#endif
  return part_v_sig_s->_v_sig;
}

/**
 * @brief get a pointer to v_sig, Signal velocity.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to v_sig. If you need read-only access to v_sig, use part_get_const_v_sig_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_v_sig_p(struct part *restrict p) {
  struct part_v_sig* part_v_sig_s = p->_cell_part_arrays->_part_v_sig + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_sig_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_sig_s->_accessor_id, p->_accessor_id);
#endif
  return &part_v_sig_s->_v_sig;
}

/**
 * @brief get read-only access to pointer to v_sig,
 * Signal velocity.
 * If you need write access to v_sig, use part_get_v_sig_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_v_sig_p(const struct part *restrict p) {
  const struct part_v_sig* part_v_sig_s = p->_cell_part_arrays->_part_v_sig + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_sig_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_sig_s->_accessor_id, p->_accessor_id);
#endif
  return &part_v_sig_s->_v_sig;
}

/**
 * @brief set the value of v_sig, Signal velocity.
 */
static __attribute__((always_inline)) INLINE void
  part_set_v_sig(struct part *restrict p, const float v_sig) {
  struct part_v_sig* part_v_sig_s = p->_cell_part_arrays->_part_v_sig + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_v_sig_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_v_sig_s->_accessor_id, p->_accessor_id);
#endif
  part_v_sig_s->_v_sig = v_sig;
}






/**
 * @brief get laplace_u, del^2 u, a smoothed quantity.
 */
static __attribute__((always_inline)) INLINE float
  part_get_laplace_u(const struct part *restrict p) {
  const struct part_laplace_u* part_laplace_u_s = p->_cell_part_arrays->_part_laplace_u + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_laplace_u_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_laplace_u_s->_accessor_id, p->_accessor_id);
#endif
  return part_laplace_u_s->_laplace_u;
}

/**
 * @brief get a pointer to laplace_u, del^2 u, a smoothed quantity.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to laplace_u. If you need read-only access to laplace_u, use part_get_const_laplace_u_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_laplace_u_p(struct part *restrict p) {
  struct part_laplace_u* part_laplace_u_s = p->_cell_part_arrays->_part_laplace_u + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_laplace_u_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_laplace_u_s->_accessor_id, p->_accessor_id);
#endif
  return &part_laplace_u_s->_laplace_u;
}

/**
 * @brief get read-only access to pointer to laplace_u,
 * del^2 u, a smoothed quantity.
 * If you need write access to laplace_u, use part_get_laplace_u_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_laplace_u_p(const struct part *restrict p) {
  const struct part_laplace_u* part_laplace_u_s = p->_cell_part_arrays->_part_laplace_u + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_laplace_u_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_laplace_u_s->_accessor_id, p->_accessor_id);
#endif
  return &part_laplace_u_s->_laplace_u;
}

/**
 * @brief set the value of laplace_u, del^2 u, a smoothed quantity.
 */
static __attribute__((always_inline)) INLINE void
  part_set_laplace_u(struct part *restrict p, const float laplace_u) {
  struct part_laplace_u* part_laplace_u_s = p->_cell_part_arrays->_part_laplace_u + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_laplace_u_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_laplace_u_s->_accessor_id, p->_accessor_id);
#endif
  part_laplace_u_s->_laplace_u = laplace_u;
}






/**
 * @brief get alpha_diff, Thermal diffusion coefficient.
 */
static __attribute__((always_inline)) INLINE float
  part_get_alpha_diff(const struct part *restrict p) {
  const struct part_alpha_diff* part_alpha_diff_s = p->_cell_part_arrays->_part_alpha_diff + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_alpha_diff_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_alpha_diff_s->_accessor_id, p->_accessor_id);
#endif
  return part_alpha_diff_s->_alpha_diff;
}

/**
 * @brief get a pointer to alpha_diff, Thermal diffusion coefficient.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to alpha_diff. If you need read-only access to alpha_diff, use part_get_const_alpha_diff_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_alpha_diff_p(struct part *restrict p) {
  struct part_alpha_diff* part_alpha_diff_s = p->_cell_part_arrays->_part_alpha_diff + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_alpha_diff_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_alpha_diff_s->_accessor_id, p->_accessor_id);
#endif
  return &part_alpha_diff_s->_alpha_diff;
}

/**
 * @brief get read-only access to pointer to alpha_diff,
 * Thermal diffusion coefficient.
 * If you need write access to alpha_diff, use part_get_alpha_diff_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_alpha_diff_p(const struct part *restrict p) {
  const struct part_alpha_diff* part_alpha_diff_s = p->_cell_part_arrays->_part_alpha_diff + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_alpha_diff_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_alpha_diff_s->_accessor_id, p->_accessor_id);
#endif
  return &part_alpha_diff_s->_alpha_diff;
}

/**
 * @brief set the value of alpha_diff, Thermal diffusion coefficient.
 */
static __attribute__((always_inline)) INLINE void
  part_set_alpha_diff(struct part *restrict p, const float alpha_diff) {
  struct part_alpha_diff* part_alpha_diff_s = p->_cell_part_arrays->_part_alpha_diff + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_alpha_diff_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_alpha_diff_s->_accessor_id, p->_accessor_id);
#endif
  part_alpha_diff_s->_alpha_diff = alpha_diff;
}






/**
 * @brief get wcount, Neighbour number count.
 */
static __attribute__((always_inline)) INLINE float
  part_get_wcount(const struct part *restrict p) {
  const struct part_density_force1* part_density_force1_s = p->_cell_part_arrays->_part_density_force1 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force1_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force1_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force1_s->_wcount;
}

/**
 * @brief get a pointer to wcount, Neighbour number count.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to wcount. If you need read-only access to wcount, use part_get_const_wcount_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_wcount_p(struct part *restrict p) {
  struct part_density_force1* part_density_force1_s = p->_cell_part_arrays->_part_density_force1 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force1_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force1_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force1_s->_wcount;
}

/**
 * @brief get read-only access to pointer to wcount,
 * Neighbour number count.
 * If you need write access to wcount, use part_get_wcount_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_wcount_p(const struct part *restrict p) {
  const struct part_density_force1* part_density_force1_s = p->_cell_part_arrays->_part_density_force1 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force1_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force1_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force1_s->_wcount;
}

/**
 * @brief set the value of wcount, Neighbour number count.
 */
static __attribute__((always_inline)) INLINE void
  part_set_wcount(struct part *restrict p, const float wcount) {
  struct part_density_force1* part_density_force1_s = p->_cell_part_arrays->_part_density_force1 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force1_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force1_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force1_s->_wcount = wcount;
}


/**
 * @brief get f_gradh, 'Grad h' term -- only partial in P-U.
 */
static __attribute__((always_inline)) INLINE float
  part_get_f_gradh(const struct part *restrict p) {
  const struct part_density_force1* part_density_force1_s = p->_cell_part_arrays->_part_density_force1 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force1_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force1_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force1_s->_f_gradh;
}

/**
 * @brief get a pointer to f_gradh, 'Grad h' term -- only partial in P-U.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to f_gradh. If you need read-only access to f_gradh, use part_get_const_f_gradh_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_f_gradh_p(struct part *restrict p) {
  struct part_density_force1* part_density_force1_s = p->_cell_part_arrays->_part_density_force1 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force1_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force1_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force1_s->_f_gradh;
}

/**
 * @brief get read-only access to pointer to f_gradh,
 * 'Grad h' term -- only partial in P-U.
 * If you need write access to f_gradh, use part_get_f_gradh_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_f_gradh_p(const struct part *restrict p) {
  const struct part_density_force1* part_density_force1_s = p->_cell_part_arrays->_part_density_force1 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force1_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force1_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force1_s->_f_gradh;
}

/**
 * @brief set the value of f_gradh, 'Grad h' term -- only partial in P-U.
 */
static __attribute__((always_inline)) INLINE void
  part_set_f_gradh(struct part *restrict p, const float f_gradh) {
  struct part_density_force1* part_density_force1_s = p->_cell_part_arrays->_part_density_force1 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force1_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force1_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force1_s->_f_gradh = f_gradh;
}






/**
 * @brief get wcount_dh, Derivative of the neighbour number with respect to h.
 */
static __attribute__((always_inline)) INLINE float
  part_get_wcount_dh(const struct part *restrict p) {
  const struct part_density_force2* part_density_force2_s = p->_cell_part_arrays->_part_density_force2 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force2_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force2_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force2_s->_wcount_dh;
}

/**
 * @brief get a pointer to wcount_dh, Derivative of the neighbour number with respect to h.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to wcount_dh. If you need read-only access to wcount_dh, use part_get_const_wcount_dh_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_wcount_dh_p(struct part *restrict p) {
  struct part_density_force2* part_density_force2_s = p->_cell_part_arrays->_part_density_force2 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force2_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force2_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force2_s->_wcount_dh;
}

/**
 * @brief get read-only access to pointer to wcount_dh,
 * Derivative of the neighbour number with respect to h.
 * If you need write access to wcount_dh, use part_get_wcount_dh_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_wcount_dh_p(const struct part *restrict p) {
  const struct part_density_force2* part_density_force2_s = p->_cell_part_arrays->_part_density_force2 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force2_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force2_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force2_s->_wcount_dh;
}

/**
 * @brief set the value of wcount_dh, Derivative of the neighbour number with respect to h.
 */
static __attribute__((always_inline)) INLINE void
  part_set_wcount_dh(struct part *restrict p, const float wcount_dh) {
  struct part_density_force2* part_density_force2_s = p->_cell_part_arrays->_part_density_force2 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force2_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force2_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force2_s->_wcount_dh = wcount_dh;
}


/**
 * @brief get pressure, Particle pressure.
 */
static __attribute__((always_inline)) INLINE float
  part_get_pressure(const struct part *restrict p) {
  const struct part_density_force2* part_density_force2_s = p->_cell_part_arrays->_part_density_force2 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force2_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force2_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force2_s->_pressure;
}

/**
 * @brief get a pointer to pressure, Particle pressure.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to pressure. If you need read-only access to pressure, use part_get_const_pressure_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_pressure_p(struct part *restrict p) {
  struct part_density_force2* part_density_force2_s = p->_cell_part_arrays->_part_density_force2 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force2_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force2_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force2_s->_pressure;
}

/**
 * @brief get read-only access to pointer to pressure,
 * Particle pressure.
 * If you need write access to pressure, use part_get_pressure_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_pressure_p(const struct part *restrict p) {
  const struct part_density_force2* part_density_force2_s = p->_cell_part_arrays->_part_density_force2 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force2_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force2_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force2_s->_pressure;
}

/**
 * @brief set the value of pressure, Particle pressure.
 */
static __attribute__((always_inline)) INLINE void
  part_set_pressure(struct part *restrict p, const float pressure) {
  struct part_density_force2* part_density_force2_s = p->_cell_part_arrays->_part_density_force2 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force2_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force2_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force2_s->_pressure = pressure;
}






/**
 * @brief get rho_dh, Derivative of density with respect to h.
 */
static __attribute__((always_inline)) INLINE float
  part_get_rho_dh(const struct part *restrict p) {
  const struct part_density_force3* part_density_force3_s = p->_cell_part_arrays->_part_density_force3 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force3_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force3_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force3_s->_rho_dh;
}

/**
 * @brief get a pointer to rho_dh, Derivative of density with respect to h.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rho_dh. If you need read-only access to rho_dh, use part_get_const_rho_dh_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_rho_dh_p(struct part *restrict p) {
  struct part_density_force3* part_density_force3_s = p->_cell_part_arrays->_part_density_force3 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force3_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force3_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force3_s->_rho_dh;
}

/**
 * @brief get read-only access to pointer to rho_dh,
 * Derivative of density with respect to h.
 * If you need write access to rho_dh, use part_get_rho_dh_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_rho_dh_p(const struct part *restrict p) {
  const struct part_density_force3* part_density_force3_s = p->_cell_part_arrays->_part_density_force3 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force3_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force3_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force3_s->_rho_dh;
}

/**
 * @brief set the value of rho_dh, Derivative of density with respect to h.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rho_dh(struct part *restrict p, const float rho_dh) {
  struct part_density_force3* part_density_force3_s = p->_cell_part_arrays->_part_density_force3 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force3_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force3_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force3_s->_rho_dh = rho_dh;
}


/**
 * @brief get soundspeed, Particle soundspeed.
 */
static __attribute__((always_inline)) INLINE float
  part_get_soundspeed(const struct part *restrict p) {
  const struct part_density_force3* part_density_force3_s = p->_cell_part_arrays->_part_density_force3 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force3_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force3_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force3_s->_soundspeed;
}

/**
 * @brief get a pointer to soundspeed, Particle soundspeed.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to soundspeed. If you need read-only access to soundspeed, use part_get_const_soundspeed_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_soundspeed_p(struct part *restrict p) {
  struct part_density_force3* part_density_force3_s = p->_cell_part_arrays->_part_density_force3 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force3_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force3_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force3_s->_soundspeed;
}

/**
 * @brief get read-only access to pointer to soundspeed,
 * Particle soundspeed.
 * If you need write access to soundspeed, use part_get_soundspeed_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_soundspeed_p(const struct part *restrict p) {
  const struct part_density_force3* part_density_force3_s = p->_cell_part_arrays->_part_density_force3 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force3_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force3_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force3_s->_soundspeed;
}

/**
 * @brief set the value of soundspeed, Particle soundspeed.
 */
static __attribute__((always_inline)) INLINE void
  part_set_soundspeed(struct part *restrict p, const float soundspeed) {
  struct part_density_force3* part_density_force3_s = p->_cell_part_arrays->_part_density_force3 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force3_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force3_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force3_s->_soundspeed = soundspeed;
}






/**
 * @brief get rot_v, Particle velocity curl,
 * for read and write access. For read-only access, use
 * part_get_const_rot_v() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_rot_v(struct part *restrict p) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force4_s->_rot_v;
}

/**
 * @brief get rot_v, Particle velocity curl, for read-only access.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_rot_v(const struct part *restrict p) {
  const struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force4_s->_rot_v;
}

/**
 * @brief get rot_v, Particle velocity curl, by index.
 */
static __attribute__((always_inline)) INLINE float
  part_get_rot_v_ind(const struct part *restrict p, const size_t ind) {
  const struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force4_s->_rot_v[ind];
}

/**
 * @brief set all values of rot_v, Particle velocity curl,
 * from an array.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rot_v(struct part *restrict p, const float rot_v[3]) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force4_s->_rot_v[0] = rot_v[0];
  part_density_force4_s->_rot_v[1] = rot_v[1];
  part_density_force4_s->_rot_v[2] = rot_v[2];
}

/**
 * @brief set the value of rot_v, Particle velocity curl, by index.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rot_v_ind(struct part *restrict p, const size_t i, const float rot_v) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force4_s->_rot_v[i] = rot_v;
}


/**
 * @brief get h_dt, Time derivative of smoothing length.
 */
static __attribute__((always_inline)) INLINE float
  part_get_h_dt(const struct part *restrict p) {
  const struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force4_s->_force._h_dt;
}

/**
 * @brief get a pointer to h_dt, Time derivative of smoothing length.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to h_dt. If you need read-only access to h_dt, use part_get_const_h_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_h_dt_p(struct part *restrict p) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force4_s->_force._h_dt;
}

/**
 * @brief get read-only access to pointer to h_dt,
 * Time derivative of smoothing length.
 * If you need write access to h_dt, use part_get_h_dt_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_h_dt_p(const struct part *restrict p) {
  const struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force4_s->_force._h_dt;
}

/**
 * @brief set the value of h_dt, Time derivative of smoothing length.
 */
static __attribute__((always_inline)) INLINE void
  part_set_h_dt(struct part *restrict p, const float h_dt) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force4_s->_force._h_dt = h_dt;
}


/**
 * @brief get balsara, Balsara switch.
 */
static __attribute__((always_inline)) INLINE float
  part_get_balsara(const struct part *restrict p) {
  const struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force4_s->_force._balsara;
}

/**
 * @brief get a pointer to balsara, Balsara switch.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to balsara. If you need read-only access to balsara, use part_get_const_balsara_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_balsara_p(struct part *restrict p) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force4_s->_force._balsara;
}

/**
 * @brief get read-only access to pointer to balsara,
 * Balsara switch.
 * If you need write access to balsara, use part_get_balsara_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_balsara_p(const struct part *restrict p) {
  const struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force4_s->_force._balsara;
}

/**
 * @brief set the value of balsara, Balsara switch.
 */
static __attribute__((always_inline)) INLINE void
  part_set_balsara(struct part *restrict p, const float balsara) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force4_s->_force._balsara = balsara;
}


/**
 * @brief get alpha_visc_max_ngb, Maximal alpha (viscosity) over neighbours.
 */
static __attribute__((always_inline)) INLINE float
  part_get_alpha_visc_max_ngb(const struct part *restrict p) {
  const struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return part_density_force4_s->_force._alpha_visc_max_ngb;
}

/**
 * @brief get a pointer to alpha_visc_max_ngb, Maximal alpha (viscosity) over neighbours.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to alpha_visc_max_ngb. If you need read-only access to alpha_visc_max_ngb, use part_get_const_alpha_visc_max_ngb_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_alpha_visc_max_ngb_p(struct part *restrict p) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force4_s->_force._alpha_visc_max_ngb;
}

/**
 * @brief get read-only access to pointer to alpha_visc_max_ngb,
 * Maximal alpha (viscosity) over neighbours.
 * If you need write access to alpha_visc_max_ngb, use part_get_alpha_visc_max_ngb_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_alpha_visc_max_ngb_p(const struct part *restrict p) {
  const struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  return &part_density_force4_s->_force._alpha_visc_max_ngb;
}

/**
 * @brief set the value of alpha_visc_max_ngb, Maximal alpha (viscosity) over neighbours.
 */
static __attribute__((always_inline)) INLINE void
  part_set_alpha_visc_max_ngb(struct part *restrict p, const float alpha_visc_max_ngb) {
  struct part_density_force4* part_density_force4_s = p->_cell_part_arrays->_part_density_force4 + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_density_force4_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_density_force4_s->_accessor_id, p->_accessor_id);
#endif
  part_density_force4_s->_force._alpha_visc_max_ngb = alpha_visc_max_ngb;
}






/**
 * @brief get adaptive_softening_data, Additional data used for adaptive softening.
 */
static __attribute__((always_inline)) INLINE struct adaptive_softening_part_data
  part_get_adaptive_softening_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_adaptive_softening_data;
}

/**
 * @brief get a pointer to adaptive_softening_data, Additional data used for adaptive softening.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to adaptive_softening_data. If you need read-only access to adaptive_softening_data, use part_get_const_adaptive_softening_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct adaptive_softening_part_data*
  part_get_adaptive_softening_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_adaptive_softening_data;
}

/**
 * @brief get read-only access to pointer to adaptive_softening_data,
 * Additional data used for adaptive softening.
 * If you need write access to adaptive_softening_data, use part_get_adaptive_softening_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct adaptive_softening_part_data*
  part_get_const_adaptive_softening_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_adaptive_softening_data;
}

/**
 * @brief set the value of adaptive_softening_data, Additional data used for adaptive softening.
 */
static __attribute__((always_inline)) INLINE void
  part_set_adaptive_softening_data(struct part *restrict p, const struct adaptive_softening_part_data adaptive_softening_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_adaptive_softening_data = adaptive_softening_data;
}




/**
 * @brief get mhd_data, Additional data used by the MHD scheme.
 */
static __attribute__((always_inline)) INLINE struct mhd_part_data
  part_get_mhd_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_mhd_data;
}

/**
 * @brief get a pointer to mhd_data, Additional data used by the MHD scheme.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to mhd_data. If you need read-only access to mhd_data, use part_get_const_mhd_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct mhd_part_data*
  part_get_mhd_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_mhd_data;
}

/**
 * @brief get read-only access to pointer to mhd_data,
 * Additional data used by the MHD scheme.
 * If you need write access to mhd_data, use part_get_mhd_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct mhd_part_data*
  part_get_const_mhd_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_mhd_data;
}

/**
 * @brief set the value of mhd_data, Additional data used by the MHD scheme.
 */
static __attribute__((always_inline)) INLINE void
  part_set_mhd_data(struct part *restrict p, const struct mhd_part_data mhd_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_mhd_data = mhd_data;
}




/**
 * @brief get chemistry_data, Chemistry information.
 */
static __attribute__((always_inline)) INLINE struct chemistry_part_data
  part_get_chemistry_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_chemistry_data;
}

/**
 * @brief get a pointer to chemistry_data, Chemistry information.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to chemistry_data. If you need read-only access to chemistry_data, use part_get_const_chemistry_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct chemistry_part_data*
  part_get_chemistry_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_chemistry_data;
}

/**
 * @brief get read-only access to pointer to chemistry_data,
 * Chemistry information.
 * If you need write access to chemistry_data, use part_get_chemistry_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct chemistry_part_data*
  part_get_const_chemistry_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_chemistry_data;
}

/**
 * @brief set the value of chemistry_data, Chemistry information.
 */
static __attribute__((always_inline)) INLINE void
  part_set_chemistry_data(struct part *restrict p, const struct chemistry_part_data chemistry_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_chemistry_data = chemistry_data;
}




/**
 * @brief get cooling_data, Cooling information.
 */
static __attribute__((always_inline)) INLINE struct cooling_part_data
  part_get_cooling_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_cooling_data;
}

/**
 * @brief get a pointer to cooling_data, Cooling information.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to cooling_data. If you need read-only access to cooling_data, use part_get_const_cooling_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct cooling_part_data*
  part_get_cooling_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_cooling_data;
}

/**
 * @brief get read-only access to pointer to cooling_data,
 * Cooling information.
 * If you need write access to cooling_data, use part_get_cooling_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct cooling_part_data*
  part_get_const_cooling_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_cooling_data;
}

/**
 * @brief set the value of cooling_data, Cooling information.
 */
static __attribute__((always_inline)) INLINE void
  part_set_cooling_data(struct part *restrict p, const struct cooling_part_data cooling_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_cooling_data = cooling_data;
}




/**
 * @brief get feedback_data, Additional data used by the feedback.
 */
static __attribute__((always_inline)) INLINE struct feedback_part_data
  part_get_feedback_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_feedback_data;
}

/**
 * @brief get a pointer to feedback_data, Additional data used by the feedback.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to feedback_data. If you need read-only access to feedback_data, use part_get_const_feedback_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct feedback_part_data*
  part_get_feedback_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_feedback_data;
}

/**
 * @brief get read-only access to pointer to feedback_data,
 * Additional data used by the feedback.
 * If you need write access to feedback_data, use part_get_feedback_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct feedback_part_data*
  part_get_const_feedback_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_feedback_data;
}

/**
 * @brief set the value of feedback_data, Additional data used by the feedback.
 */
static __attribute__((always_inline)) INLINE void
  part_set_feedback_data(struct part *restrict p, const struct feedback_part_data feedback_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_feedback_data = feedback_data;
}




/**
 * @brief get black_holes_data, Black holes information (eg swallowing ID).
 */
static __attribute__((always_inline)) INLINE struct black_holes_part_data
  part_get_black_holes_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_black_holes_data;
}

/**
 * @brief get a pointer to black_holes_data, Black holes information (eg swallowing ID).
 * Use this only if you need to modify the value, i.e. if you need write access
 * to black_holes_data. If you need read-only access to black_holes_data, use part_get_const_black_holes_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct black_holes_part_data*
  part_get_black_holes_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_black_holes_data;
}

/**
 * @brief get read-only access to pointer to black_holes_data,
 * Black holes information (eg swallowing ID).
 * If you need write access to black_holes_data, use part_get_black_holes_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct black_holes_part_data*
  part_get_const_black_holes_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_black_holes_data;
}

/**
 * @brief set the value of black_holes_data, Black holes information (eg swallowing ID).
 */
static __attribute__((always_inline)) INLINE void
  part_set_black_holes_data(struct part *restrict p, const struct black_holes_part_data black_holes_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_black_holes_data = black_holes_data;
}




/**
 * @brief get sink_data, Sink information (eg swallowing ID).
 */
static __attribute__((always_inline)) INLINE struct sink_part_data
  part_get_sink_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_sink_data;
}

/**
 * @brief get a pointer to sink_data, Sink information (eg swallowing ID).
 * Use this only if you need to modify the value, i.e. if you need write access
 * to sink_data. If you need read-only access to sink_data, use part_get_const_sink_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct sink_part_data*
  part_get_sink_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_sink_data;
}

/**
 * @brief get read-only access to pointer to sink_data,
 * Sink information (eg swallowing ID).
 * If you need write access to sink_data, use part_get_sink_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct sink_part_data*
  part_get_const_sink_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_sink_data;
}

/**
 * @brief set the value of sink_data, Sink information (eg swallowing ID).
 */
static __attribute__((always_inline)) INLINE void
  part_set_sink_data(struct part *restrict p, const struct sink_part_data sink_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_sink_data = sink_data;
}




/**
 * @brief get pressure_floor_data, Additional data used by the pressure floor.
 */
static __attribute__((always_inline)) INLINE struct pressure_floor_part_data
  part_get_pressure_floor_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_pressure_floor_data;
}

/**
 * @brief get a pointer to pressure_floor_data, Additional data used by the pressure floor.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to pressure_floor_data. If you need read-only access to pressure_floor_data, use part_get_const_pressure_floor_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct pressure_floor_part_data*
  part_get_pressure_floor_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_pressure_floor_data;
}

/**
 * @brief get read-only access to pointer to pressure_floor_data,
 * Additional data used by the pressure floor.
 * If you need write access to pressure_floor_data, use part_get_pressure_floor_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct pressure_floor_part_data*
  part_get_const_pressure_floor_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_pressure_floor_data;
}

/**
 * @brief set the value of pressure_floor_data, Additional data used by the pressure floor.
 */
static __attribute__((always_inline)) INLINE void
  part_set_pressure_floor_data(struct part *restrict p, const struct pressure_floor_part_data pressure_floor_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_pressure_floor_data = pressure_floor_data;
}




/**
 * @brief get geometry, Geometrical quantities used for Finite Volume Particle Method RT.
 */
static __attribute__((always_inline)) INLINE struct fvpm_geometry_struct
  part_get_geometry(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_geometry;
}

/**
 * @brief get a pointer to geometry, Geometrical quantities used for Finite Volume Particle Method RT.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to geometry. If you need read-only access to geometry, use part_get_const_geometry_p() instead.
 */
static __attribute__((always_inline)) INLINE struct fvpm_geometry_struct*
  part_get_geometry_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_geometry;
}

/**
 * @brief get read-only access to pointer to geometry,
 * Geometrical quantities used for Finite Volume Particle Method RT.
 * If you need write access to geometry, use part_get_geometry_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct fvpm_geometry_struct*
  part_get_const_geometry_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_geometry;
}

/**
 * @brief set the value of geometry, Geometrical quantities used for Finite Volume Particle Method RT.
 */
static __attribute__((always_inline)) INLINE void
  part_set_geometry(struct part *restrict p, const struct fvpm_geometry_struct geometry) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_geometry = geometry;
}




/**
 * @brief get rt_data, Additional Radiative Transfer Data.
 */
static __attribute__((always_inline)) INLINE struct rt_part_data
  part_get_rt_data(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return part_additional_structs_s->_rt_data;
}

/**
 * @brief get a pointer to rt_data, Additional Radiative Transfer Data.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rt_data. If you need read-only access to rt_data, use part_get_const_rt_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct rt_part_data*
  part_get_rt_data_p(struct part *restrict p) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_rt_data;
}

/**
 * @brief get read-only access to pointer to rt_data,
 * Additional Radiative Transfer Data.
 * If you need write access to rt_data, use part_get_rt_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct rt_part_data*
  part_get_const_rt_data_p(const struct part *restrict p) {
  const struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  return &part_additional_structs_s->_rt_data;
}

/**
 * @brief set the value of rt_data, Additional Radiative Transfer Data.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rt_data(struct part *restrict p, const struct rt_part_data rt_data) {
  struct part_additional_structs* part_additional_structs_s = p->_cell_part_arrays->_part_additional_structs + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_additional_structs_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_additional_structs_s->_accessor_id, p->_accessor_id);
#endif
  part_additional_structs_s->_rt_data = rt_data;
}






/**
 * @brief get rt_time_data, RT sub-cycling time stepping data.
 */
static __attribute__((always_inline)) INLINE struct rt_timestepping_data
  part_get_rt_time_data(const struct part *restrict p) {
  const struct part_rt_time_data* part_rt_time_data_s = p->_cell_part_arrays->_part_rt_time_data + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_rt_time_data_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_rt_time_data_s->_accessor_id, p->_accessor_id);
#endif
  return part_rt_time_data_s->_rt_time_data;
}

/**
 * @brief get a pointer to rt_time_data, RT sub-cycling time stepping data.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rt_time_data. If you need read-only access to rt_time_data, use part_get_const_rt_time_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct rt_timestepping_data*
  part_get_rt_time_data_p(struct part *restrict p) {
  struct part_rt_time_data* part_rt_time_data_s = p->_cell_part_arrays->_part_rt_time_data + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_rt_time_data_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_rt_time_data_s->_accessor_id, p->_accessor_id);
#endif
  return &part_rt_time_data_s->_rt_time_data;
}

/**
 * @brief get read-only access to pointer to rt_time_data,
 * RT sub-cycling time stepping data.
 * If you need write access to rt_time_data, use part_get_rt_time_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct rt_timestepping_data*
  part_get_const_rt_time_data_p(const struct part *restrict p) {
  const struct part_rt_time_data* part_rt_time_data_s = p->_cell_part_arrays->_part_rt_time_data + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_rt_time_data_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_rt_time_data_s->_accessor_id, p->_accessor_id);
#endif
  return &part_rt_time_data_s->_rt_time_data;
}

/**
 * @brief set the value of rt_time_data, RT sub-cycling time stepping data.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rt_time_data(struct part *restrict p, const struct rt_timestepping_data rt_time_data) {
  struct part_rt_time_data* part_rt_time_data_s = p->_cell_part_arrays->_part_rt_time_data + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_rt_time_data_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_rt_time_data_s->_accessor_id, p->_accessor_id);
#endif
  part_rt_time_data_s->_rt_time_data = rt_time_data;
}






/**
 * @brief get depth_h, Tree-depth at which size / 2 <= h * gamma < size.
 */
static __attribute__((always_inline)) INLINE char
  part_get_depth_h(const struct part *restrict p) {
  const struct part_depth_h* part_depth_h_s = p->_cell_part_arrays->_part_depth_h + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_depth_h_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_depth_h_s->_accessor_id, p->_accessor_id);
#endif
  return part_depth_h_s->_depth_h;
}

/**
 * @brief get a pointer to depth_h, Tree-depth at which size / 2 <= h * gamma < size.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to depth_h. If you need read-only access to depth_h, use part_get_const_depth_h_p() instead.
 */
static __attribute__((always_inline)) INLINE char*
  part_get_depth_h_p(struct part *restrict p) {
  struct part_depth_h* part_depth_h_s = p->_cell_part_arrays->_part_depth_h + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_depth_h_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_depth_h_s->_accessor_id, p->_accessor_id);
#endif
  return &part_depth_h_s->_depth_h;
}

/**
 * @brief get read-only access to pointer to depth_h,
 * Tree-depth at which size / 2 <= h * gamma < size.
 * If you need write access to depth_h, use part_get_depth_h_p() instead.
 */
static __attribute__((always_inline)) INLINE const char*
  part_get_const_depth_h_p(const struct part *restrict p) {
  const struct part_depth_h* part_depth_h_s = p->_cell_part_arrays->_part_depth_h + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_depth_h_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_depth_h_s->_accessor_id, p->_accessor_id);
#endif
  return &part_depth_h_s->_depth_h;
}

/**
 * @brief set the value of depth_h, Tree-depth at which size / 2 <= h * gamma < size.
 */
static __attribute__((always_inline)) INLINE void
  part_set_depth_h(struct part *restrict p, const char depth_h) {
  struct part_depth_h* part_depth_h_s = p->_cell_part_arrays->_part_depth_h + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_depth_h_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_depth_h_s->_accessor_id, p->_accessor_id);
#endif
  part_depth_h_s->_depth_h = depth_h;
}






/**
 * @brief get time_bin, Time-step length.
 */
static __attribute__((always_inline)) INLINE timebin_t
  part_get_time_bin(const struct part *restrict p) {
  const struct part_time_bin* part_time_bin_s = p->_cell_part_arrays->_part_time_bin + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_time_bin_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_time_bin_s->_accessor_id, p->_accessor_id);
#endif
  return part_time_bin_s->_time_bin;
}

/**
 * @brief get a pointer to time_bin, Time-step length.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to time_bin. If you need read-only access to time_bin, use part_get_const_time_bin_p() instead.
 */
static __attribute__((always_inline)) INLINE timebin_t*
  part_get_time_bin_p(struct part *restrict p) {
  struct part_time_bin* part_time_bin_s = p->_cell_part_arrays->_part_time_bin + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_time_bin_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_time_bin_s->_accessor_id, p->_accessor_id);
#endif
  return &part_time_bin_s->_time_bin;
}

/**
 * @brief get read-only access to pointer to time_bin,
 * Time-step length.
 * If you need write access to time_bin, use part_get_time_bin_p() instead.
 */
static __attribute__((always_inline)) INLINE const timebin_t*
  part_get_const_time_bin_p(const struct part *restrict p) {
  const struct part_time_bin* part_time_bin_s = p->_cell_part_arrays->_part_time_bin + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_time_bin_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_time_bin_s->_accessor_id, p->_accessor_id);
#endif
  return &part_time_bin_s->_time_bin;
}

/**
 * @brief set the value of time_bin, Time-step length.
 */
static __attribute__((always_inline)) INLINE void
  part_set_time_bin(struct part *restrict p, const timebin_t time_bin) {
  struct part_time_bin* part_time_bin_s = p->_cell_part_arrays->_part_time_bin + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_time_bin_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_time_bin_s->_accessor_id, p->_accessor_id);
#endif
  part_time_bin_s->_time_bin = time_bin;
}






/**
 * @brief get limiter_data, Time-step limiter information.
 */
static __attribute__((always_inline)) INLINE struct timestep_limiter_data
  part_get_limiter_data(const struct part *restrict p) {
  const struct part_limiter_data* part_limiter_data_s = p->_cell_part_arrays->_part_limiter_data + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_limiter_data_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_limiter_data_s->_accessor_id, p->_accessor_id);
#endif
  return part_limiter_data_s->_limiter_data;
}

/**
 * @brief get a pointer to limiter_data, Time-step limiter information.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to limiter_data. If you need read-only access to limiter_data, use part_get_const_limiter_data_p() instead.
 */
static __attribute__((always_inline)) INLINE struct timestep_limiter_data*
  part_get_limiter_data_p(struct part *restrict p) {
  struct part_limiter_data* part_limiter_data_s = p->_cell_part_arrays->_part_limiter_data + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_limiter_data_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_limiter_data_s->_accessor_id, p->_accessor_id);
#endif
  return &part_limiter_data_s->_limiter_data;
}

/**
 * @brief get read-only access to pointer to limiter_data,
 * Time-step limiter information.
 * If you need write access to limiter_data, use part_get_limiter_data_p() instead.
 */
static __attribute__((always_inline)) INLINE const struct timestep_limiter_data*
  part_get_const_limiter_data_p(const struct part *restrict p) {
  const struct part_limiter_data* part_limiter_data_s = p->_cell_part_arrays->_part_limiter_data + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_limiter_data_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_limiter_data_s->_accessor_id, p->_accessor_id);
#endif
  return &part_limiter_data_s->_limiter_data;
}

/**
 * @brief set the value of limiter_data, Time-step limiter information.
 */
static __attribute__((always_inline)) INLINE void
  part_set_limiter_data(struct part *restrict p, const struct timestep_limiter_data limiter_data) {
  struct part_limiter_data* part_limiter_data_s = p->_cell_part_arrays->_part_limiter_data + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_limiter_data_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_limiter_data_s->_accessor_id, p->_accessor_id);
#endif
  part_limiter_data_s->_limiter_data = limiter_data;
}






/**
 * @brief get ti_drift, Time of the last drift.
 */
static __attribute__((always_inline)) INLINE integertime_t
  part_get_ti_drift(const struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  const struct part_ti_drift* part_ti_drift_s = p->_cell_part_arrays->_part_ti_drift + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_ti_drift_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_ti_drift_s->_accessor_id, p->_accessor_id);

  return part_ti_drift_s->_ti_drift;
#else
  return LLONG_MAX;
#endif
}

/**
 * @brief get a pointer to ti_drift, Time of the last drift.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to ti_drift. If you need read-only access to ti_drift, use part_get_const_ti_drift_p() instead.
 */
static __attribute__((always_inline)) INLINE integertime_t*
  part_get_ti_drift_p(struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  struct part_ti_drift* part_ti_drift_s = p->_cell_part_arrays->_part_ti_drift + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_ti_drift_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_ti_drift_s->_accessor_id, p->_accessor_id);

  return &part_ti_drift_s->_ti_drift;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to ti_drift,
 * Time of the last drift.
 * If you need write access to ti_drift, use part_get_ti_drift_p() instead.
 */
static __attribute__((always_inline)) INLINE const integertime_t*
  part_get_const_ti_drift_p(const struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  const struct part_ti_drift* part_ti_drift_s = p->_cell_part_arrays->_part_ti_drift + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_ti_drift_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_ti_drift_s->_accessor_id, p->_accessor_id);

  return &part_ti_drift_s->_ti_drift;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of ti_drift, Time of the last drift.
 */
static __attribute__((always_inline)) INLINE void
  part_set_ti_drift(struct part *restrict p, const integertime_t ti_drift) {
#ifdef SWIFT_DEBUG_CHECKS
  struct part_ti_drift* part_ti_drift_s = p->_cell_part_arrays->_part_ti_drift + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_ti_drift_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_ti_drift_s->_accessor_id, p->_accessor_id);

  part_ti_drift_s->_ti_drift = ti_drift;
#endif
}






/**
 * @brief get ti_kick, Time of the last drift.
 */
static __attribute__((always_inline)) INLINE integertime_t
  part_get_ti_kick(const struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  const struct part_ti_kick* part_ti_kick_s = p->_cell_part_arrays->_part_ti_kick + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_ti_kick_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_ti_kick_s->_accessor_id, p->_accessor_id);

  return part_ti_kick_s->_ti_kick;
#else
  return LLONG_MAX;
#endif
}

/**
 * @brief get a pointer to ti_kick, Time of the last drift.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to ti_kick. If you need read-only access to ti_kick, use part_get_const_ti_kick_p() instead.
 */
static __attribute__((always_inline)) INLINE integertime_t*
  part_get_ti_kick_p(struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  struct part_ti_kick* part_ti_kick_s = p->_cell_part_arrays->_part_ti_kick + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_ti_kick_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_ti_kick_s->_accessor_id, p->_accessor_id);

  return &part_ti_kick_s->_ti_kick;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to ti_kick,
 * Time of the last drift.
 * If you need write access to ti_kick, use part_get_ti_kick_p() instead.
 */
static __attribute__((always_inline)) INLINE const integertime_t*
  part_get_const_ti_kick_p(const struct part *restrict p) {
#ifdef SWIFT_DEBUG_CHECKS
  const struct part_ti_kick* part_ti_kick_s = p->_cell_part_arrays->_part_ti_kick + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_ti_kick_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_ti_kick_s->_accessor_id, p->_accessor_id);

  return &part_ti_kick_s->_ti_kick;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of ti_kick, Time of the last drift.
 */
static __attribute__((always_inline)) INLINE void
  part_set_ti_kick(struct part *restrict p, const integertime_t ti_kick) {
#ifdef SWIFT_DEBUG_CHECKS
  struct part_ti_kick* part_ti_kick_s = p->_cell_part_arrays->_part_ti_kick + p->_cell_offset;

  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_ti_kick_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_ti_kick_s->_accessor_id, p->_accessor_id);

  part_ti_kick_s->_ti_kick = ti_kick;
#endif
}






/**
 * @brief get N_density, Integer number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_density(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_N_density;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_density, Integer number of neighbours in the density loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_density. If you need read-only access to N_density, use part_get_const_N_density_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_density_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_density;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_density,
 * Integer number of neighbours in the density loop.
 * If you need write access to N_density, use part_get_N_density_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_density_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_density;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_density, Integer number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_density(struct part *restrict p, const int N_density) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_N_density = N_density;
#endif
}




/**
 * @brief get N_density_exact, Exact integer number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_density_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_N_density_exact;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_density_exact, Exact integer number of neighbours in the density loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_density_exact. If you need read-only access to N_density_exact, use part_get_const_N_density_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_density_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_density_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_density_exact,
 * Exact integer number of neighbours in the density loop.
 * If you need write access to N_density_exact, use part_get_N_density_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_density_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_density_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_density_exact, Exact integer number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_density_exact(struct part *restrict p, const int N_density_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_N_density_exact = N_density_exact;
#endif
}




/**
 * @brief get N_gradient, Integer number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_gradient(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_N_gradient;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_gradient, Integer number of neighbours in the gradient loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_gradient. If you need read-only access to N_gradient, use part_get_const_N_gradient_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_gradient_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_gradient;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_gradient,
 * Integer number of neighbours in the gradient loop.
 * If you need write access to N_gradient, use part_get_N_gradient_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_gradient_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_gradient;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_gradient, Integer number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_gradient(struct part *restrict p, const int N_gradient) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_N_gradient = N_gradient;
#endif
}




/**
 * @brief get N_gradient_exact, Exact integer number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_gradient_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_N_gradient_exact;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_gradient_exact, Exact integer number of neighbours in the gradient loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_gradient_exact. If you need read-only access to N_gradient_exact, use part_get_const_N_gradient_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_gradient_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_gradient_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_gradient_exact,
 * Exact integer number of neighbours in the gradient loop.
 * If you need write access to N_gradient_exact, use part_get_N_gradient_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_gradient_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_gradient_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_gradient_exact, Exact integer number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_gradient_exact(struct part *restrict p, const int N_gradient_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_N_gradient_exact = N_gradient_exact;
#endif
}




/**
 * @brief get N_force, Integer number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_force(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_N_force;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_force, Integer number of neighbours in the force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_force. If you need read-only access to N_force, use part_get_const_N_force_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_force_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_force;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_force,
 * Integer number of neighbours in the force loop.
 * If you need write access to N_force, use part_get_N_force_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_force_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_force;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_force, Integer number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_force(struct part *restrict p, const int N_force) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_N_force = N_force;
#endif
}




/**
 * @brief get N_force_exact, Exact integer number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE int
  part_get_N_force_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_N_force_exact;
#else
  return INT_MAX;
#endif
}

/**
 * @brief get a pointer to N_force_exact, Exact integer number of neighbours in the force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to N_force_exact. If you need read-only access to N_force_exact, use part_get_const_N_force_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE int*
  part_get_N_force_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_force_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to N_force_exact,
 * Exact integer number of neighbours in the force loop.
 * If you need write access to N_force_exact, use part_get_N_force_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const int*
  part_get_const_N_force_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_N_force_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of N_force_exact, Exact integer number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_N_force_exact(struct part *restrict p, const int N_force_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_N_force_exact = N_force_exact;
#endif
}




/**
 * @brief get rho_exact, Exact value of the density field obtained via brute-force loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_rho_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_rho_exact;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to rho_exact, Exact value of the density field obtained via brute-force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to rho_exact. If you need read-only access to rho_exact, use part_get_const_rho_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_rho_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_rho_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to rho_exact,
 * Exact value of the density field obtained via brute-force loop.
 * If you need write access to rho_exact, use part_get_rho_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_rho_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_rho_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of rho_exact, Exact value of the density field obtained via brute-force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_rho_exact(struct part *restrict p, const float rho_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_rho_exact = rho_exact;
#endif
}




/**
 * @brief get n_density, Weighted number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_density(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_n_density;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_density, Weighted number of neighbours in the density loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_density. If you need read-only access to n_density, use part_get_const_n_density_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_density_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_density;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_density,
 * Weighted number of neighbours in the density loop.
 * If you need write access to n_density, use part_get_n_density_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_density_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_density;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_density, Weighted number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_density(struct part *restrict p, const float n_density) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_n_density = n_density;
#endif
}




/**
 * @brief get n_density_exact, Exact value of the weighted number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_density_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_n_density_exact;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_density_exact, Exact value of the weighted number of neighbours in the density loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_density_exact. If you need read-only access to n_density_exact, use part_get_const_n_density_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_density_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_density_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_density_exact,
 * Exact value of the weighted number of neighbours in the density loop.
 * If you need write access to n_density_exact, use part_get_n_density_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_density_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_density_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_density_exact, Exact value of the weighted number of neighbours in the density loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_density_exact(struct part *restrict p, const float n_density_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_n_density_exact = n_density_exact;
#endif
}




/**
 * @brief get n_gradient, Weighted number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_gradient(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_n_gradient;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_gradient, Weighted number of neighbours in the gradient loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_gradient. If you need read-only access to n_gradient, use part_get_const_n_gradient_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_gradient_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_gradient;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_gradient,
 * Weighted number of neighbours in the gradient loop.
 * If you need write access to n_gradient, use part_get_n_gradient_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_gradient_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_gradient;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_gradient, Weighted number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_gradient(struct part *restrict p, const float n_gradient) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_n_gradient = n_gradient;
#endif
}




/**
 * @brief get n_gradient_exact, Exact value of the weighted number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_gradient_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_n_gradient_exact;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_gradient_exact, Exact value of the weighted number of neighbours in the gradient loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_gradient_exact. If you need read-only access to n_gradient_exact, use part_get_const_n_gradient_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_gradient_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_gradient_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_gradient_exact,
 * Exact value of the weighted number of neighbours in the gradient loop.
 * If you need write access to n_gradient_exact, use part_get_n_gradient_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_gradient_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_gradient_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_gradient_exact, Exact value of the weighted number of neighbours in the gradient loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_gradient_exact(struct part *restrict p, const float n_gradient_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_n_gradient_exact = n_gradient_exact;
#endif
}




/**
 * @brief get n_force, Weighted number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_force(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_n_force;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_force, Weighted number of neighbours in the force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_force. If you need read-only access to n_force, use part_get_const_n_force_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_force_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_force;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_force,
 * Weighted number of neighbours in the force loop.
 * If you need write access to n_force, use part_get_n_force_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_force_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_force;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_force, Weighted number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_force(struct part *restrict p, const float n_force) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_n_force = n_force;
#endif
}




/**
 * @brief get n_force_exact, Exact value of the weighted number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE float
  part_get_n_force_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_n_force_exact;
#else
  return FLT_MAX;
#endif
}

/**
 * @brief get a pointer to n_force_exact, Exact value of the weighted number of neighbours in the force loop.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to n_force_exact. If you need read-only access to n_force_exact, use part_get_const_n_force_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE float*
  part_get_n_force_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_force_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to n_force_exact,
 * Exact value of the weighted number of neighbours in the force loop.
 * If you need write access to n_force_exact, use part_get_n_force_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const float*
  part_get_const_n_force_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_n_force_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of n_force_exact, Exact value of the weighted number of neighbours in the force loop.
 */
static __attribute__((always_inline)) INLINE void
  part_set_n_force_exact(struct part *restrict p, const float n_force_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_n_force_exact = n_force_exact;
#endif
}




/**
 * @brief get inhibited_exact, Has this particle interacted with any unhibited neighbour?.
 */
static __attribute__((always_inline)) INLINE char
  part_get_inhibited_exact(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_inhibited_exact;
#else
  return CHAR_MAX;
#endif
}

/**
 * @brief get a pointer to inhibited_exact, Has this particle interacted with any unhibited neighbour?.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to inhibited_exact. If you need read-only access to inhibited_exact, use part_get_const_inhibited_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE char*
  part_get_inhibited_exact_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_inhibited_exact;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to inhibited_exact,
 * Has this particle interacted with any unhibited neighbour?.
 * If you need write access to inhibited_exact, use part_get_inhibited_exact_p() instead.
 */
static __attribute__((always_inline)) INLINE const char*
  part_get_const_inhibited_exact_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_inhibited_exact;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of inhibited_exact, Has this particle interacted with any unhibited neighbour?.
 */
static __attribute__((always_inline)) INLINE void
  part_set_inhibited_exact(struct part *restrict p, const char inhibited_exact) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_inhibited_exact = inhibited_exact;
#endif
}




/**
 * @brief get limited_part, Has this particle been woken up by the limiter?.
 */
static __attribute__((always_inline)) INLINE char
  part_get_limited_part(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return part_debugging_s->_limited_part;
#else
  return CHAR_MAX;
#endif
}

/**
 * @brief get a pointer to limited_part, Has this particle been woken up by the limiter?.
 * Use this only if you need to modify the value, i.e. if you need write access
 * to limited_part. If you need read-only access to limited_part, use part_get_const_limited_part_p() instead.
 */
static __attribute__((always_inline)) INLINE char*
  part_get_limited_part_p(struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_limited_part;
#else
  return NULL;
#endif
}

/**
 * @brief get read-only access to pointer to limited_part,
 * Has this particle been woken up by the limiter?.
 * If you need write access to limited_part, use part_get_limited_part_p() instead.
 */
static __attribute__((always_inline)) INLINE const char*
  part_get_const_limited_part_p(const struct part *restrict p) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  const struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  return &part_debugging_s->_limited_part;
#else
  return NULL;
#endif
}

/**
 * @brief set the value of limited_part, Has this particle been woken up by the limiter?.
 */
static __attribute__((always_inline)) INLINE void
  part_set_limited_part(struct part *restrict p, const char limited_part) {
#ifdef SWIFT_HYDRO_DENSITY_CHECKS
  struct part_debugging* part_debugging_s = p->_cell_part_arrays->_part_debugging + p->_cell_offset;
#ifdef SWIFT_DEBUG_CHECKS
  /* Forbid ID = 0 to prevent false positives by forgotten initialisation */
  swift_assert(p->_accessor_id != 0);
  /* Make sure we're accessing the correct data */
  if(part_debugging_s->_accessor_id != p->_accessor_id)
    error("Accessor IDs not equal: %lld %lld", part_debugging_s->_accessor_id, p->_accessor_id);
#endif
  part_debugging_s->_limited_part = limited_part;
#endif
}







#endif /* SWIFT_HYDRO_PART_45f18804078753c6002db4c09d1e7203629af930_H */
